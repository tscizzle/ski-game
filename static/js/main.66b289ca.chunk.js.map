{"version":3,"sources":["gameConstants.js","gameHelpers.js","gameScenes/mountainSlope.js","gameScenes/skiTiltDisplay.js","gameScenes/resetButton.js","components/app/app.js","game.js","serviceWorker.js","index.js"],"names":["GAME_WIDTH","_","max","window","innerWidth","GAME_HEIGHT","innerHeight","publicURL","path","concat","process","smallestAngleDifference","a","b","Math","atan2","sin","cos","MountainSlope","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","load","image","slopeSteepness","PI","slopeDirection","gravityAccelerationConstant","previousAngularVelocity","previousTurnDirection","previousTiltAmount","previousTiltDirection","previousBackCorner","isCrashed","refDistance","refArrows","add","sprite","each","arrow","setScale","skiBody","leftSki","rightSki","skiPlayer","container","physics","world","enable","edgeSnowParticles","particles","edgeSnowEmitter","createEmitter","radial","lifespan","quantity","angle","min","blendMode","on","cameras","main","setBackgroundColor","startFollow","skiTurningCursors","input","keyboard","createCursorKeys","skiTiltCursors","addKeys","up","Phaser","Input","Keyboard","KeyCodes","W","down","S","left","A","right","D","drawReferenceObjects","controlRotation","controlTilt","accelerationDueToGravity","x","y","slopeFactor","gravityAccelerationDirection","isNull","rotation","traversalFactor","accelerationMagnitude","velocityAngle","body","velocity","skisPerpendicularLeft","skisPerpendicularRight","skisPerpendicularAngle","abs","turnFactor","skisPerpendicularSpeed","speed","skisPerpendicularAcceleration","accelerationDueToEdges","acceleration","setAcceleration","snowEmissionSpeed","scrapeStrength","isScraping","isEmitterOn","start","scrapeEdge","skisBackCorner","getBottomLeft","getBottomRight","skisFrontCorner","getTopLeft","getTopRight","scrapingLine","Geom","Line","setEmitZone","source","type","setSpeed","newEmitterFrequency","newEmitterScale","roundedScrapeStrength","floor","frequency","setFrequency","end","graphics","setDefaultStyles","lineStyle","width","color","line","lineBetween","tween","targets","duration","alpha","onComplete","destroy","crash","stop","maxAngularVelocity","angularAcceleration","currentAngularVelocity","isDown","tiltAmount","tiltDirection","skisScaleX","closestBelow","closestLeft","closestRight","closestAbove","setPosition","setVelocity","crashedSkis","setAngle","setLifespan","explode","shake","events","emit","Scene","SkiTiltDisplay","key","active","displayCenterX","displayWidth","displayCenterY","displayHeight","fillStyle","strokeRect","fillRect","skis","slopeScene","scene","get","tiltRotation","ResetButton","_this","rectArgs","strokeRoundedRect","apply","fillRoundedRect","text","fontSize","fontStyle","setOrigin","resetButton","zone","setInteractive","useHandCursor","manager","scenes","restart","App","containerId","_ref","parent","gameConfig","height","default","AUTO","Game","initializeGame","react_default","createElement","className","id","Component","Boolean","location","hostname","match","ReactDOM","render","app_app","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.66b289ca.chunk.js","sourcesContent":["import _ from 'lodash';\n\nexport const GAME_WIDTH = _.max([window.innerWidth - 6, 1200]);\nexport const GAME_HEIGHT = _.max([window.innerHeight - 6, 800]);\n","export const publicURL = path => {\n  return `${process.env.PUBLIC_URL}${path}`;\n};\n\nexport const smallestAngleDifference = (a, b) => {\n  return Math.atan2(Math.sin(a - b), Math.cos(a - b));\n};\n","import _ from 'lodash';\nimport Phaser from 'phaser';\n\nimport { publicURL, smallestAngleDifference } from 'gameHelpers';\nimport { GAME_WIDTH, GAME_HEIGHT } from 'gameConstants';\n\nclass MountainSlope extends Phaser.Scene {\n  constructor() {\n    super('MountainSlope');\n  }\n\n  /* MAIN PHASER METHODS */\n\n  preload() {\n    this.load.image('arrows', publicURL('/gameAssets/images/racingArrows.png'));\n    this.load.image('skiBody', publicURL('/gameAssets/images/skiBody.png'));\n    this.load.image('leftSki', publicURL('/gameAssets/images/leftSki.png'));\n    this.load.image('rightSki', publicURL('/gameAssets/images/rightSki.png'));\n    this.load.image(\n      'snowParticle',\n      publicURL('/gameAssets/images/snowParticle.png')\n    );\n    this.load.image(\n      'crashedSkis',\n      publicURL('/gameAssets/images/crashedSkis.png')\n    );\n  }\n\n  create() {\n    // INITIALIZE CONSTANTS\n    this.slopeSteepness = Math.PI / 6; // angle with ground\n    this.slopeDirection = 0; // angle rotated clockwise from forward\n    this.gravityAccelerationConstant = 500;\n\n    // INITIALIZE VALUES THAT GET UPDATED\n    this.previousAngularVelocity = 0;\n    this.previousTurnDirection = null;\n    this.previousTiltAmount = 0;\n    this.previousTiltDirection = null;\n    this.previousBackCorner = null;\n    this.isCrashed = false;\n\n    // VISUAL OBJECTS\n    this.refDistance = _.max([GAME_WIDTH, GAME_HEIGHT]) / 2 + 100;\n    this.refArrows = [\n      this.add.sprite(0, 0, 'arrows'),\n      this.add.sprite(0, this.refDistance, 'arrows'),\n      this.add.sprite(this.refDistance, 0, 'arrows'),\n      this.add.sprite(this.refDistance, this.refDistance, 'arrows'),\n    ];\n    _.each(this.refArrows, arrow => arrow.setScale(0.75));\n    this.skiBody = this.add.sprite(0, 0, 'skiBody');\n    this.leftSki = this.add.sprite(-40, 0, 'leftSki');\n    this.rightSki = this.add.sprite(40, 0, 'rightSki');\n    this.skiPlayer = this.add.container(\n      this.refDistance / 2,\n      this.refDistance / 2,\n      [this.skiBody, this.leftSki, this.rightSki]\n    );\n    this.skiPlayer.setScale(0.25);\n    this.physics.world.enable(this.skiPlayer);\n    this.edgeSnowParticles = this.add.particles('snowParticle');\n    this.edgeSnowEmitter = this.edgeSnowParticles.createEmitter({\n      radial: false,\n      lifespan: 375,\n      quantity: 5,\n      angle: { min: -100, max: -80 },\n      blendMode: 'ADD',\n      on: false,\n    });\n\n    // CAMERA\n    this.cameras.main.setBackgroundColor(0xf0f0f0);\n    this.cameras.main.startFollow(this.skiPlayer);\n\n    // CONTROLS\n    this.skiTurningCursors = this.input.keyboard.createCursorKeys();\n    this.skiTiltCursors = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D,\n    });\n\n    // this.scene.pause();\n  }\n\n  update() {\n    this.drawReferenceObjects();\n\n    if (!this.isCrashed) {\n      this.controlRotation();\n      this.controlTilt();\n    }\n\n    // ACCELERATION DUE TO GRAVITY\n    let accelerationDueToGravity = { x: 0, y: 0 };\n    if (!this.isCrashed) {\n      // acceleration lessened by the ground\n      const slopeFactor = Math.sin(this.slopeSteepness);\n      // acceleration is parallel to skis if they are tilted. otherwise\n      // acceleration is in direction of the slope.\n      const gravityAccelerationDirection = _.isNull(this.previousTiltDirection)\n        ? this.slopeDirection\n        : this.skiPlayer.rotation;\n      // acceleration lessened if acceleration not lined up with the slope\n      // direction\n      const traversalFactor = Math.cos(\n        gravityAccelerationDirection - this.slopeDirection\n      );\n      // slope and traversal factors scale the gravity constant to get the\n      // acceleration\n      const accelerationMagnitude =\n        this.gravityAccelerationConstant * slopeFactor * traversalFactor;\n      // split this acceleration into its x-y components\n      accelerationDueToGravity = {\n        x: Math.sin(gravityAccelerationDirection) * accelerationMagnitude,\n        y: -Math.cos(gravityAccelerationDirection) * accelerationMagnitude,\n      };\n    }\n\n    // DECELERATE DUE TO SKI EDGES\n    // acceleration decreases with velocity perpendicular to the skis\n    const velocityAngle = Math.atan2(\n      this.skiPlayer.body.velocity.x,\n      -this.skiPlayer.body.velocity.y\n    );\n    const skisPerpendicularLeft = this.skiPlayer.rotation - Math.PI / 2;\n    const skisPerpendicularRight = this.skiPlayer.rotation + Math.PI / 2;\n    const leftDiff = Math.abs(\n      smallestAngleDifference(skisPerpendicularLeft, velocityAngle)\n    );\n    const rightDiff = Math.abs(\n      smallestAngleDifference(skisPerpendicularRight, velocityAngle)\n    );\n    const skisPerpendicularAngle =\n      leftDiff < rightDiff ? skisPerpendicularLeft : skisPerpendicularRight;\n    const turnFactor = Math.cos(velocityAngle - skisPerpendicularAngle);\n    // turn factor scales the velocity to get the (negative) acceleration in the\n    // direction perpendicular to the skis\n    const skisPerpendicularSpeed = this.skiPlayer.body.speed * turnFactor;\n    // scale the acceleration by the amount the skis are tilted, with some\n    // scrape even when there's no tilt\n    const tiltFactor = 0.1 + this.previousTiltAmount * 0.9;\n    const skisPerpendicularAcceleration = -skisPerpendicularSpeed * tiltFactor;\n    // split this acceleration into its x-y components\n    const accelerationDueToEdges = {\n      x: Math.sin(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n      y: -Math.cos(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n    };\n\n    // APPLY NET ACCELERATION\n    const acceleration = {\n      x: accelerationDueToGravity.x + accelerationDueToEdges.x,\n      y: accelerationDueToGravity.y + accelerationDueToEdges.y,\n    };\n    this.skiPlayer.body.setAcceleration(acceleration.x, acceleration.y);\n\n    // SCRAPE EFFECTS\n    const snowEmissionSpeed = skisPerpendicularSpeed * 1.1;\n    const scrapeStrength = Math.abs(skisPerpendicularAcceleration);\n    const isScraping = scrapeStrength >= 100;\n    const isEmitterOn = this.edgeSnowEmitter.on;\n    if (isScraping) {\n      if (!isEmitterOn) {\n        this.edgeSnowEmitter.start();\n      }\n      // set the angle and speed of the snow emissions\n      const scrapeEdge =\n        skisPerpendicularAngle === skisPerpendicularLeft ? 'left' : 'right';\n      const skisBackCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getBottomLeft(null, true)\n          : this.skiBody.getBottomRight(null, true);\n      const skisFrontCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getTopLeft(null, true)\n          : this.skiBody.getTopRight(null, true);\n      const scrapingLine = new Phaser.Geom.Line(\n        skisBackCorner.x,\n        skisBackCorner.y,\n        skisFrontCorner.x,\n        skisFrontCorner.y\n      );\n      this.edgeSnowEmitter.setEmitZone({\n        source: scrapingLine,\n        type: 'random',\n      });\n      this.edgeSnowEmitter.setSpeed(snowEmissionSpeed);\n      // set the frequency and size of the snow emissions\n      const roundedScrapeStrength = Math.floor(scrapeStrength / 200) * 200;\n      const ceilingScrapeStrength = 1000;\n      const slowestEmitterFrequency = 50;\n      const fastestEmitterFrequency = 0;\n      const maxEmitterScale = 0.25;\n      const minEmitterScale = 0.05;\n      let newEmitterFrequency;\n      let newEmitterScale;\n      if (roundedScrapeStrength >= ceilingScrapeStrength) {\n        newEmitterFrequency = fastestEmitterFrequency;\n        newEmitterScale = maxEmitterScale;\n      } else {\n        newEmitterFrequency =\n          slowestEmitterFrequency *\n          (1 - roundedScrapeStrength / ceilingScrapeStrength);\n        newEmitterScale =\n          (maxEmitterScale - minEmitterScale) *\n            (roundedScrapeStrength / ceilingScrapeStrength) +\n          minEmitterScale;\n      }\n      if (newEmitterFrequency !== this.edgeSnowEmitter.frequency) {\n        this.edgeSnowEmitter.setFrequency(newEmitterFrequency);\n        this.edgeSnowEmitter.setScale({ start: newEmitterScale, end: 0 });\n      }\n      // leave a trail in the snow\n      if (this.previousBackCorner) {\n        const graphics = this.add.graphics();\n        graphics.setDefaultStyles({ lineStyle: { width: 3, color: 0xcccccc } });\n        const line = graphics.lineBetween(\n          this.previousBackCorner.x,\n          this.previousBackCorner.y,\n          skisBackCorner.x,\n          skisBackCorner.y\n        );\n        this.add.tween({\n          targets: [line],\n          duration: 1000,\n          alpha: 0,\n          onComplete() {\n            line.destroy();\n            graphics.destroy();\n          },\n        });\n      }\n      this.previousBackCorner = skisBackCorner;\n\n      // fall off skis if tilting toward the scrape\n      if (scrapeEdge === this.previousTiltDirection) {\n        this.crash();\n      }\n    } else {\n      if (isEmitterOn) {\n        this.edgeSnowEmitter.stop();\n      }\n      this.previousBackCorner = null;\n    }\n  }\n\n  /* GAME HELPERS */\n\n  controlRotation() {\n    const maxAngularVelocity = Math.PI / 70;\n    const angularAcceleration = Math.PI / 1000;\n    const currentAngularVelocity = _.min([\n      this.previousAngularVelocity + angularAcceleration,\n      maxAngularVelocity,\n    ]);\n    if (this.skiTurningCursors.left.isDown) {\n      if (this.previousTurnDirection !== 'right') {\n        this.skiPlayer.rotation -= currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'left';\n    } else if (this.skiTurningCursors.right.isDown) {\n      if (this.previousTurnDirection !== 'left') {\n        this.skiPlayer.rotation += currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'right';\n    } else {\n      this.previousAngularVelocity = 0;\n      this.previousTurnDirection = null;\n    }\n  }\n\n  controlTilt() {\n    const maxSkisScale = 1;\n    const minSkisScale = 0.8;\n    const maxTilt = 1;\n    const minTilt = 0;\n    const tiltVelocity = 0.05;\n    let tiltAmount;\n    let tiltDirection = this.previousTiltDirection;\n    if (this.skiTiltCursors.left.isDown) {\n      if (this.previousTiltDirection !== 'right') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'left';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else if (this.skiTiltCursors.right.isDown) {\n      if (this.previousTiltDirection !== 'left') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'right';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else {\n      tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n    }\n    if (tiltAmount === 0) {\n      tiltDirection = null;\n    }\n    const skisScaleX =\n      maxSkisScale * (1 - tiltAmount) + minSkisScale * tiltAmount;\n    this.leftSki.setScale(skisScaleX, maxSkisScale);\n    this.rightSki.setScale(skisScaleX, maxSkisScale);\n    this.previousTiltAmount = tiltAmount;\n    this.previousTiltDirection = tiltDirection;\n  }\n\n  drawReferenceObjects() {\n    const closestBelow =\n      Math.floor(this.skiPlayer.y / this.refDistance) * this.refDistance;\n    const closestLeft =\n      Math.floor(this.skiPlayer.x / this.refDistance) * this.refDistance;\n    const needNewRefs =\n      this.refArrows[0].x !== closestLeft ||\n      this.refArrows[0].y !== closestBelow;\n    if (needNewRefs) {\n      const closestRight = closestLeft + this.refDistance;\n      const closestAbove = closestBelow + this.refDistance;\n      this.refArrows[0].setPosition(closestLeft, closestBelow);\n      this.refArrows[1].setPosition(closestLeft, closestAbove);\n      this.refArrows[2].setPosition(closestRight, closestBelow);\n      this.refArrows[3].setPosition(closestRight, closestAbove);\n    }\n  }\n\n  crash() {\n    this.isCrashed = true;\n    this.skiPlayer.body.setVelocity(0);\n    this.skiPlayer.body.setAcceleration(0);\n    this.leftSki.destroy();\n    this.rightSki.destroy();\n    this.crashedSkis = this.add.sprite(0, 0, 'crashedSkis');\n    this.skiPlayer.add(this.crashedSkis);\n    this.edgeSnowEmitter.setScale({ start: 1, end: 0 });\n    this.edgeSnowEmitter.setAngle({ min: 0, max: 360 });\n    this.edgeSnowEmitter.setLifespan(750);\n    this.edgeSnowEmitter.setSpeed(150);\n    this.edgeSnowEmitter.explode(30, 0, 0);\n    this.cameras.main.shake(300, 0.07);\n    this.events.emit('crash');\n  }\n}\n\nexport default MountainSlope;\n","import Phaser from 'phaser';\n\nimport { publicURL } from 'gameHelpers';\nimport { GAME_WIDTH, GAME_HEIGHT } from 'gameConstants';\n\nclass SkiTiltDisplay extends Phaser.Scene {\n  constructor() {\n    super({ key: 'SkiTiltDisplay', active: true });\n  }\n\n  /* MAIN PHASER METHODS */\n\n  preload() {\n    this.load.image(\n      'leftSkiBack',\n      publicURL('/gameAssets/images/leftSkiBack.png')\n    );\n    this.load.image(\n      'rightSkiBack',\n      publicURL('/gameAssets/images/rightSkiBack.png')\n    );\n  }\n\n  create() {\n    const displayWidth = 240;\n    const displayHeight = 110;\n    const displayCenterX = GAME_WIDTH - 45 - displayWidth / 2;\n    const displayCenterY = GAME_HEIGHT - 45 - displayHeight / 2;\n\n    const graphics = this.add.graphics();\n    graphics.setDefaultStyles({\n      lineStyle: { width: 7, color: 0x777777 },\n      fillStyle: { color: 0xdddddd },\n    });\n    graphics.strokeRect(\n      displayCenterX - displayWidth / 2,\n      displayCenterY - displayHeight / 2,\n      displayWidth,\n      displayHeight\n    );\n    graphics.fillRect(\n      displayCenterX - displayWidth / 2,\n      displayCenterY - displayHeight / 2,\n      displayWidth,\n      displayHeight\n    );\n\n    this.leftSki = this.add.sprite(-220, 0, 'leftSkiBack');\n    this.rightSki = this.add.sprite(220, 0, 'rightSkiBack');\n    this.skis = this.add.container(displayCenterX, displayCenterY, [\n      this.leftSki,\n      this.rightSki,\n    ]);\n    this.skis.setScale(0.23);\n  }\n\n  update() {\n    const slopeScene = this.scene.get('MountainSlope');\n    const {\n      previousTiltAmount: tiltAmount,\n      previousTiltDirection: tiltDirection,\n    } = slopeScene;\n    const minRotation = 0;\n    const maxRotation = Math.PI / 4;\n    const tiltRotationSign = tiltDirection === 'left' ? -1 : 1;\n    const tiltRotationMagnitude =\n      minRotation * (1 - tiltAmount) + maxRotation * tiltAmount;\n    const tiltRotation = tiltRotationMagnitude * tiltRotationSign;\n    this.leftSki.rotation = tiltRotation;\n    this.rightSki.rotation = tiltRotation;\n  }\n}\n\nexport default SkiTiltDisplay;\n","import _ from 'lodash';\nimport Phaser from 'phaser';\n\nimport { GAME_WIDTH, GAME_HEIGHT } from 'gameConstants';\n\nclass ResetButton extends Phaser.Scene {\n  constructor() {\n    super({ key: 'ResetButton', active: true });\n  }\n\n  create() {\n    const displayWidth = 320;\n    const displayHeight = 160;\n    const displayCenterX = GAME_WIDTH / 2;\n    const displayCenterY = GAME_HEIGHT - 45 - displayHeight / 2;\n\n    const slopeScene = this.scene.get('MountainSlope');\n    slopeScene.events.on('crash', () => {\n      const graphics = this.add.graphics();\n      graphics.setDefaultStyles({\n        lineStyle: { width: 8, color: 0x44aa44 },\n        fillStyle: { color: 0x88dd88 },\n      });\n      const rectArgs = [\n        displayCenterX - displayWidth / 2,\n        displayCenterY - displayHeight / 2,\n        displayWidth,\n        displayHeight,\n        5,\n      ];\n      graphics.strokeRoundedRect(...rectArgs);\n      graphics.fillRoundedRect(...rectArgs);\n      const resetButtonText = this.add.text(\n        displayCenterX,\n        displayCenterY,\n        'Lift Back Up',\n        { color: '#228822', fontSize: '28px', fontStyle: 'bold' }\n      );\n      resetButtonText.setOrigin(0.5, 0.5);\n      const resetButton = this.add.zone(\n        displayCenterX,\n        displayCenterY,\n        displayWidth,\n        displayHeight\n      );\n      resetButton.setInteractive({ useHandCursor: true });\n      resetButton.on('pointerup', () => {\n        _.each(this.scene.manager.scenes, scene => scene.scene.restart());\n      });\n    });\n  }\n}\n\nexport default ResetButton;\n","import React, { Component } from 'react';\n\nimport { initializeGame } from 'game';\nimport 'stylesheets/components/app/app.css';\n\nclass App extends Component {\n  containerId = 'game-container';\n\n  componentDidMount() {\n    initializeGame({ parent: this.containerId });\n  }\n\n  render() {\n    return (\n      <div className=\"app\">\n        <div id={this.containerId} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import Phaser from 'phaser';\n\nimport { GAME_WIDTH, GAME_HEIGHT } from 'gameConstants';\nimport MountainSlope from 'gameScenes/mountainSlope';\nimport SkiTiltDisplay from 'gameScenes/skiTiltDisplay';\nimport ResetButton from 'gameScenes/resetButton';\n\nexport const initializeGame = ({ parent }) => {\n  const gameConfig = {\n    width: GAME_WIDTH,\n    height: GAME_HEIGHT,\n    scene: [MountainSlope, SkiTiltDisplay, ResetButton],\n    physics: {\n      default: 'arcade',\n    },\n    type: Phaser.AUTO,\n    parent,\n  };\n  const game = new Phaser.Game(gameConfig);\n  return game;\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'stylesheets/index.css';\nimport App from './components/app/app';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}