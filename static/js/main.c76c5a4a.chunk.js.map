{"version":3,"sources":["game.js","components/app/app.js","serviceWorker.js","index.js"],"names":["SkiSlope","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","publicURL","path","concat","process","smallestAngleDifference","a","b","Math","atan2","sin","cos","load","image","slopeSteepness","PI","slopeDirection","gravityAccelerationConstant","previousAngularVelocity","previousTurnDirection","previousTiltAmount","previousTiltDirection","previousBackCorner","standingOnSkis","refArrows","add","sprite","_","each","arrow","setScale","skiBody","leftSki","rightSki","skiPlayer","container","physics","world","enable","edgeSnowParticles","particles","edgeSnowEmitter","createEmitter","radial","lifespan","blendMode","on","cameras","main","setBackgroundColor","startFollow","skiTurningCursors","input","keyboard","createCursorKeys","skiTiltCursors","addKeys","up","Phaser","Input","Keyboard","KeyCodes","W","down","S","left","A","right","D","maxAngularVelocity","angularAcceleration","currentAngularVelocity","min","isDown","rotation","tiltAmount","tiltDirection","max","skisScaleX","slopeFactor","gravityAccelerationDirection","isNull","traversalFactor","accelerationMagnitude","accelerationDueToGravity","velocityAngle","body","velocity","x","y","skisPerpendicularLeft","skisPerpendicularRight","skisPerpendicularAngle","abs","turnFactor","skisPerpendicularSpeed","speed","skisPerpendicularAcceleration","acceleration","setAcceleration","closestBelow","floor","closestLeft","closestRight","closestAbove","setPosition","snowEmissionSpeed","scrapeStrength","isScraping","isEmitterOn","start","scrapeEdge","skisBackCorner","getBottomLeft","getBottomRight","skisFrontCorner","getTopLeft","getTopRight","scrapingLine","Geom","Line","setEmitZone","source","type","setSpeed","setAngle","newEmitterFrequency","newEmitterScale","roundedScrapeStrength","frequency","setFrequency","end","graphics","setDefaultStyles","lineStyle","width","color","line","lineBetween","tween","targets","duration","alpha","onComplete","destroy","stop","setVelocity","Scene","App","gameConfig","AUTO","height","scene","default","Game","initializeGame","react_default","createElement","className","Component","Boolean","window","location","hostname","match","ReactDOM","render","app_app","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c76c5a4a.chunk.js","sourcesContent":["import _ from 'lodash';\nimport Phaser from 'phaser';\n\nclass SkiSlope extends Phaser.Scene {\n  constructor() {\n    super('SkiSlope');\n  }\n\n  preload() {\n    this.load.image(\n      'arrows',\n      this.publicURL('gameAssets/images/racingArrows.png')\n    );\n    this.load.image('skiBody', this.publicURL('gameAssets/images/skiBody.png'));\n    this.load.image('leftSki', this.publicURL('gameAssets/images/leftSki.png'));\n    this.load.image(\n      'rightSki',\n      this.publicURL('gameAssets/images/rightSki.png')\n    );\n    this.load.image(\n      'snowParticle',\n      this.publicURL('gameAssets/images/snowParticle.png')\n    );\n  }\n\n  create() {\n    // INITIALIZE CONSTANTS\n    this.slopeSteepness = Math.PI / 6; // angle with ground\n    this.slopeDirection = 0; // angle rotated clockwise from forward\n    this.gravityAccelerationConstant = 500;\n\n    // INITIALIZE VALUES THAT GET UPDATED\n    this.previousAngularVelocity = 0;\n    this.previousTurnDirection = null;\n    this.previousTiltAmount = 0;\n    this.previousTiltDirection = null;\n    this.previousBackCorner = null;\n    this.standingOnSkis = true;\n\n    // VISUAL OBJECTS\n    this.refArrows = [\n      this.add.sprite(0, 0, 'arrows'),\n      this.add.sprite(0, 500, 'arrows'),\n      this.add.sprite(500, 0, 'arrows'),\n      this.add.sprite(500, 500, 'arrows'),\n    ];\n    _.each(this.refArrows, arrow => arrow.setScale(0.75));\n    this.skiBody = this.add.sprite(0, 0, 'skiBody');\n    this.leftSki = this.add.sprite(-40, 0, 'leftSki');\n    this.rightSki = this.add.sprite(40, 0, 'rightSki');\n    this.skiPlayer = this.add.container(250, 250, [\n      this.skiBody,\n      this.leftSki,\n      this.rightSki,\n    ]);\n    this.skiPlayer.setScale(0.25);\n    this.physics.world.enable(this.skiPlayer);\n    this.edgeSnowParticles = this.add.particles('snowParticle');\n    this.edgeSnowEmitter = this.edgeSnowParticles.createEmitter({\n      radial: false,\n      lifespan: 400,\n      blendMode: 'ADD',\n      on: false,\n    });\n\n    // CAMERA\n    this.cameras.main.setBackgroundColor(0xf0f0f0);\n    this.cameras.main.startFollow(this.skiPlayer);\n\n    // CONTROLS\n    this.skiTurningCursors = this.input.keyboard.createCursorKeys();\n    this.skiTiltCursors = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D,\n    });\n\n    // this.scene.pause();\n  }\n\n  update() {\n    // CONTROL ROTATION\n    const maxAngularVelocity = Math.PI / 70;\n    const angularAcceleration = Math.PI / 1000;\n    const currentAngularVelocity = _.min([\n      this.previousAngularVelocity + angularAcceleration,\n      maxAngularVelocity,\n    ]);\n    if (this.skiTurningCursors.left.isDown) {\n      if (this.previousTurnDirection !== 'right') {\n        this.skiPlayer.rotation -= currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'left';\n    } else if (this.skiTurningCursors.right.isDown) {\n      if (this.previousTurnDirection !== 'left') {\n        this.skiPlayer.rotation += currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'right';\n    } else {\n      this.previousAngularVelocity = 0;\n      this.previousTurnDirection = null;\n    }\n\n    // CONTROL TILT\n    const maxSkisScale = 1;\n    const minSkisScale = 0.8;\n    const maxTilt = 1;\n    const minTilt = 0;\n    const tiltVelocity = 0.05;\n    let tiltAmount;\n    let tiltDirection = this.previousTiltDirection;\n    if (this.skiTiltCursors.left.isDown) {\n      if (this.previousTiltDirection !== 'right') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'left';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else if (this.skiTiltCursors.right.isDown) {\n      if (this.previousTiltDirection !== 'left') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'right';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else {\n      tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n    }\n    if (tiltAmount === 0) {\n      tiltDirection = null;\n    }\n    const skisScaleX =\n      maxSkisScale * (1 - tiltAmount) + minSkisScale * tiltAmount;\n    this.leftSki.setScale(skisScaleX, maxSkisScale);\n    this.rightSki.setScale(skisScaleX, maxSkisScale);\n    this.previousTiltAmount = tiltAmount;\n    this.previousTiltDirection = tiltDirection;\n\n    // ACCELERATE DUE TO GRAVITY\n    // acceleration lessened by the ground\n    const slopeFactor = Math.sin(this.slopeSteepness);\n    // acceleration is parallel to skis if they are tilted. otherwise\n    // acceleration is in direction of the slope.\n    const gravityAccelerationDirection = _.isNull(tiltDirection)\n      ? this.slopeDirection\n      : this.skiPlayer.rotation;\n    // acceleration lessened if acceleration not lined up with the slope\n    // direction\n    const traversalFactor = Math.cos(\n      gravityAccelerationDirection - this.slopeDirection\n    );\n    // slope and traversal factors scale the gravity constant to get the\n    // acceleration\n    const accelerationMagnitude =\n      this.gravityAccelerationConstant * slopeFactor * traversalFactor;\n    // split this acceleration into its x-y components\n    const accelerationDueToGravity = {\n      x: Math.sin(gravityAccelerationDirection) * accelerationMagnitude,\n      y: -Math.cos(gravityAccelerationDirection) * accelerationMagnitude,\n    };\n\n    // DECELERATE DUE TO SKI EDGES\n    // acceleration decreases with velocity perpendicular to the skis\n    const velocityAngle = Math.atan2(\n      this.skiPlayer.body.velocity.x,\n      -this.skiPlayer.body.velocity.y\n    );\n    const skisPerpendicularLeft = this.skiPlayer.rotation - Math.PI / 2;\n    const skisPerpendicularRight = this.skiPlayer.rotation + Math.PI / 2;\n    const leftDiff = Math.abs(\n      this.smallestAngleDifference(skisPerpendicularLeft, velocityAngle)\n    );\n    const rightDiff = Math.abs(\n      this.smallestAngleDifference(skisPerpendicularRight, velocityAngle)\n    );\n    const skisPerpendicularAngle =\n      leftDiff < rightDiff ? skisPerpendicularLeft : skisPerpendicularRight;\n    const turnFactor = Math.cos(velocityAngle - skisPerpendicularAngle);\n    // turn factor scales the velocity to get the (negative) acceleration in the\n    // direction perpendicular to the skis\n    const skisPerpendicularSpeed = this.skiPlayer.body.speed * turnFactor;\n    // scale the acceleration by the amount the skis are tilted, with some\n    // scrape even when there's no tilt\n    const tiltFactor = 0.1 + tiltAmount * 0.9;\n    const skisPerpendicularAcceleration = -skisPerpendicularSpeed * tiltFactor;\n    // split this acceleration into its x-y components\n    const accelerationDueToEdging = {\n      x: Math.sin(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n      y: -Math.cos(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n    };\n\n    // APPLY NET ACCELERATION\n    const acceleration = {\n      x: accelerationDueToGravity.x + accelerationDueToEdging.x,\n      y: accelerationDueToGravity.y + accelerationDueToEdging.y,\n    };\n    this.skiPlayer.body.setAcceleration(acceleration.x, acceleration.y);\n\n    // DRAW REFERENCE OBJECTS\n    const refDistance = 500;\n    const closestBelow =\n      Math.floor(this.skiPlayer.y / refDistance) * refDistance;\n    const closestLeft =\n      Math.floor(this.skiPlayer.x / refDistance) * refDistance;\n    const needNewRefs =\n      this.refArrows[0].x !== closestLeft ||\n      this.refArrows[0].y !== closestBelow;\n    if (needNewRefs) {\n      const closestRight = closestLeft + refDistance;\n      const closestAbove = closestBelow + refDistance;\n      this.refArrows[0].setPosition(closestLeft, closestBelow);\n      this.refArrows[1].setPosition(closestLeft, closestAbove);\n      this.refArrows[2].setPosition(closestRight, closestBelow);\n      this.refArrows[3].setPosition(closestRight, closestAbove);\n    }\n\n    // SCRAPE EFFECTS\n    const snowEmissionSpeed = skisPerpendicularSpeed * 1.1;\n    const scrapeStrength = Math.abs(skisPerpendicularAcceleration);\n    const isScraping = scrapeStrength >= 100;\n    const isEmitterOn = this.edgeSnowEmitter.on;\n    if (isScraping) {\n      if (!isEmitterOn) {\n        this.edgeSnowEmitter.start();\n      }\n      // set the angle and speed of the snow emissions\n      const scrapeEdge =\n        skisPerpendicularAngle === skisPerpendicularLeft ? 'left' : 'right';\n      const skisBackCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getBottomLeft(null, true)\n          : this.skiBody.getBottomRight(null, true);\n      const skisFrontCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getTopLeft(null, true)\n          : this.skiBody.getTopRight(null, true);\n      const scrapingLine = new Phaser.Geom.Line(\n        skisBackCorner.x,\n        skisBackCorner.y,\n        skisFrontCorner.x,\n        skisFrontCorner.y\n      );\n      this.edgeSnowEmitter.setEmitZone({\n        source: scrapingLine,\n        type: 'random',\n      });\n      this.edgeSnowEmitter.setSpeed(snowEmissionSpeed);\n      this.edgeSnowEmitter.setAngle(-90);\n      // set the frequency and size of the snow emissions\n      const roundedScrapeStrength = Math.floor(scrapeStrength / 200) * 200;\n      const ceilingScrapeStrength = 1000;\n      const slowestEmitterFrequency = 50;\n      const fastestEmitterFrequency = 0;\n      const maxEmitterScale = 0.25;\n      const minEmitterScale = 0.05;\n      let newEmitterFrequency;\n      let newEmitterScale;\n      if (roundedScrapeStrength >= ceilingScrapeStrength) {\n        newEmitterFrequency = fastestEmitterFrequency;\n        newEmitterScale = maxEmitterScale;\n      } else {\n        newEmitterFrequency =\n          slowestEmitterFrequency *\n          (1 - roundedScrapeStrength / ceilingScrapeStrength);\n        newEmitterScale =\n          (maxEmitterScale - minEmitterScale) *\n            (roundedScrapeStrength / ceilingScrapeStrength) +\n          minEmitterScale;\n      }\n      if (newEmitterFrequency !== this.edgeSnowEmitter.frequency) {\n        this.edgeSnowEmitter.setFrequency(newEmitterFrequency);\n        this.edgeSnowEmitter.setScale({ start: newEmitterScale, end: 0 });\n      }\n      // leave a trail in the snow\n      if (this.previousBackCorner) {\n        const graphics = this.add.graphics();\n        graphics.setDefaultStyles({ lineStyle: { width: 3, color: 0xcccccc } });\n        const line = graphics.lineBetween(\n          this.previousBackCorner.x,\n          this.previousBackCorner.y,\n          skisBackCorner.x,\n          skisBackCorner.y\n        );\n        this.add.tween({\n          targets: [line],\n          duration: 1000,\n          alpha: 0,\n          onComplete() {\n            line.destroy();\n            graphics.destroy();\n          },\n        });\n      }\n      this.previousBackCorner = skisBackCorner;\n\n      // fall off skis if tilting toward the scrape\n      if (scrapeEdge === tiltDirection) {\n        this.standingOnSkis = false;\n      }\n    } else {\n      if (isEmitterOn) {\n        this.edgeSnowEmitter.stop();\n      }\n      this.previousBackCorner = null;\n    }\n\n    // CRASH IF NO LONGER ON SKIS\n    if (!this.standingOnSkis) {\n      this.skiPlayer.body.setVelocity(0);\n      this.skiPlayer.body.setAcceleration(0);\n    }\n  }\n\n  /* HELPERS */\n\n  publicURL = path => `${process.env.PUBLIC_URL}${path}`;\n\n  smallestAngleDifference = (a, b) => {\n    return Math.atan2(Math.sin(a - b), Math.cos(a - b));\n  };\n}\n\nexport const initializeGame = () => {\n  const gameConfig = {\n    type: Phaser.AUTO,\n    width: 800,\n    height: 800,\n    scene: [SkiSlope],\n    physics: {\n      default: 'arcade',\n    },\n  };\n  const game = new Phaser.Game(gameConfig);\n  return game;\n};\n","import React, { Component } from 'react';\n\nimport { initializeGame } from 'game';\nimport 'stylesheets/components/app/app.css';\n\nclass App extends Component {\n  componentDidMount() {\n    initializeGame();\n  }\n\n  render() {\n    return <div className=\"app\" />;\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'stylesheets/index.css';\nimport App from './components/app/app';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}