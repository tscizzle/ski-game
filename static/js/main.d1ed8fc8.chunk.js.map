{"version":3,"sources":["gameConstants.js","gameHelpers.js","gameScenes/mountainSlope.js","gameScenes/logoScene.js","gameScenes/vectorLegend.js","gameScenes/skiTiltDisplay.js","gameScenes/resetButton.js","components/app/app.js","game.js","serviceWorker.js","index.js"],"names":["GAME_WIDTH","_","max","window","innerWidth","GAME_HEIGHT","innerHeight","GAME_PADDING","publicURL","path","concat","process","mapValBetween","min","val","smallestAngleDifference","a","b","Math","atan2","sin","cos","makeArrow","_ref","x","y","scene","start","end","color","arrowLength","sqrt","pow","preRotatedEnd","headAltitudeLength","PI","shaft","Phaser","Geom","Line","head","Triangle","headSideLength","directionX","directionY","rotation","RotateAroundPoint","graphics","add","setDefaultStyles","lineStyle","width","fillStyle","fillTriangleShape","strokeLineShape","MountainSlope","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","load","image","slopeSteepness","slopeDirection","gravityAccelerationConstant","previousAngularVelocity","previousTurnDirection","previousTiltAmount","previousTiltDirection","previousBackCorner","isCrashed","refDistance","refMarkers","sprite","each","marker","setScale","skiBody","leftSki","rightSki","skiPlayer","container","physics","world","enable","edgeSnowParticles","particles","edgeSnowEmitter","createEmitter","radial","lifespan","quantity","angle","blendMode","on","cameras","main","setBackgroundColor","startFollow","skiTurningCursors","input","keyboard","createCursorKeys","skiTiltCursors","addKeys","up","Input","Keyboard","KeyCodes","W","down","S","left","A","right","D","drawReferenceObjects","controlRotation","controlTilt","storeSkiPlayerValues","drawRotationArrow","drawVelocityArrow","accelerationDueToGravity","slopeFactor","gravityAccelerationDirection","isNull","traversalFactor","accelerationMagnitude","velocityAngle","body","velocity","skisPerpendicularLeft","skisPerpendicularRight","skisPerpendicularAngle","abs","turnFactor","skisPerpendicularSpeed","speed","skisPerpendicularAcceleration","accelerationDueToEdges","acceleration","setAcceleration","snowEmissionSpeed","scrapeStrength","isScraping","isEmitterOn","scrapeEdge","skisBackCorner","getBottomLeft","getBottomRight","skisFrontCorner","getTopLeft","getTopRight","scrapingLine","setEmitZone","source","type","setSpeed","newEmitterFrequency","newEmitterScale","newEmitterQuantity","roundedScrapeStrength","floor","frequency","setFrequency","setQuantity","line","lineBetween","tween","targets","duration","alpha","onComplete","destroy","crash","stop","maxAngularVelocity","angularAcceleration","currentAngularVelocity","isDown","tiltAmount","tiltDirection","skisScaleX","storedSkiPlayerPosition","storedSkiPlayerRotation","storedSkiPlayerVelocity","storedSkiPlayerSpeed","skisFacingArrowGraphics","vectorInfo","get","vectorInfos","velocityArrowGraphics","n","stretch","arguments","length","undefined","mapInfToOne","arrowLengthX","arrowLengthY","closestBelow","closestLeft","closestRight","closestAbove","setPosition","setVelocity","crashedSkis","setAngle","setLifespan","explode","shake","events","emit","Scene","LogoScene","key","active","logo","setOrigin","VectorLegend","_this","itemWidth","itemHeight","itemMargin","itemTitleSize","vectorsListTitleSize","legendItemCenter","idx","_this2","boxGraphics","title","drawLegendItem","text","fontSize","fontStyle","_this3","_ref2","_this$legendItemCente","centerX","centerY","fillRect","toggleButton","zone","setInteractive","useHandCursor","drawLegendItemBorder","textColor","toString","_ref3","_this$legendItemCente2","strokeRect","SkiTiltDisplay","displayCenterX","displayWidth","displayCenterY","displayHeight","skis","slopeScene","tiltRotation","ResetButton","rectArgs","strokeRoundedRect","apply","fillRoundedRect","resetButton","manager","scenes","restart","App","containerId","parent","gameConfig","height","default","AUTO","Game","initializeGame","react_default","createElement","className","id","Component","Boolean","location","hostname","match","ReactDOM","render","app_app","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d1ed8fc8.chunk.js","sourcesContent":["import _ from 'lodash';\n\nexport const GAME_WIDTH = _.max([window.innerWidth - 6, 1200]);\nexport const GAME_HEIGHT = _.max([window.innerHeight - 6, 800]);\nexport const GAME_PADDING = 46;\n","import Phaser from 'phaser';\n\nexport const publicURL = path => {\n  return `${process.env.PUBLIC_URL}${path}`;\n};\n\nexport const mapValBetween = (min, max, val) => {\n  /* Function to linearly map val=0 to min and val=1 to max */\n  return (max - min) * val + min;\n};\n\nexport const mapInfToOne = (n, stretch = 0.999) => {\n  /* Function to map n=0 to 0 and n=infinity to 1\n  > stretch should be between 0 and 1 and the higher it is, the slower the\n  function grows to 1\n  */\n  return 1 - stretch ** n;\n};\n\nexport const smallestAngleDifference = (a, b) => {\n  return Math.atan2(Math.sin(a - b), Math.cos(a - b));\n};\n\nexport const angleFromUp = (x, y) => {\n  /* using Phaser's x and y axes (positive x is right, positive y is down), get\n  the angle between the vector <x, y> and the straight up direction (the\n  negative y axis) */\n  return Math.atan2(x, -y);\n};\n\nexport const makeArrow = ({ scene, start, end, color }) => {\n  // compute shaft and head oriented straight up\n  const arrowLength = Math.sqrt(\n    (end.x - start.x) ** 2 + (end.y - start.y) ** 2\n  );\n  const preRotatedEnd = { x: start.x, y: start.y - arrowLength };\n  const headSideLength = 12;\n  const headAltitudeLength = headSideLength * Math.sin(Math.PI / 3);\n  const shaft = new Phaser.Geom.Line(\n    start.x,\n    start.y,\n    preRotatedEnd.x,\n    preRotatedEnd.y + headAltitudeLength // the head covers the end of the shaft\n  );\n  const head = new Phaser.Geom.Triangle(\n    end.x,\n    end.y,\n    end.x - headSideLength / 2,\n    end.y + headAltitudeLength,\n    end.x + headSideLength / 2,\n    end.y + headAltitudeLength\n  );\n  // rotate the shaft and head\n  const directionX = end.x - start.x;\n  const directionY = end.y - start.y;\n  const rotation = angleFromUp(directionX, directionY);\n  Phaser.Geom.Triangle.RotateAroundPoint(head, end, rotation);\n  Phaser.Geom.Line.RotateAroundPoint(shaft, start, rotation);\n  // stroke the shaft and head\n  const graphics = scene.add.graphics();\n  graphics.setDefaultStyles({\n    lineStyle: { width: 3, color },\n    fillStyle: { color },\n  });\n  graphics.fillTriangleShape(head);\n  graphics.strokeLineShape(shaft);\n  return graphics;\n};\n","import _ from 'lodash';\nimport Phaser from 'phaser';\n\nimport {\n  publicURL,\n  mapValBetween,\n  mapInfToOne,\n  smallestAngleDifference,\n  makeArrow,\n} from 'gameHelpers';\nimport { GAME_WIDTH, GAME_HEIGHT } from 'gameConstants';\n\nclass MountainSlope extends Phaser.Scene {\n  constructor() {\n    super('MountainSlope');\n  }\n\n  /* MAIN PHASER METHODS */\n\n  preload() {\n    this.load.image(\n      'refMarkers',\n      publicURL('/gameAssets/images/racingArrows.png')\n    );\n    this.load.image('skiBody', publicURL('/gameAssets/images/skiBody.png'));\n    this.load.image('leftSki', publicURL('/gameAssets/images/leftSki.png'));\n    this.load.image('rightSki', publicURL('/gameAssets/images/rightSki.png'));\n    this.load.image(\n      'snowParticle',\n      publicURL('/gameAssets/images/snowParticle.png')\n    );\n    this.load.image(\n      'crashedSkis',\n      publicURL('/gameAssets/images/crashedSkis.png')\n    );\n  }\n\n  create() {\n    // INITIALIZE CONSTANTS\n    this.slopeSteepness = Math.PI / 6; // angle with ground\n    this.slopeDirection = 0; // angle rotated clockwise from forward\n    this.gravityAccelerationConstant = 500;\n\n    // INITIALIZE VALUES THAT GET UPDATED\n    this.previousAngularVelocity = 0;\n    this.previousTurnDirection = null;\n    this.previousTiltAmount = 0;\n    this.previousTiltDirection = null;\n    this.previousBackCorner = null;\n    this.isCrashed = false;\n\n    // VISUAL OBJECTS\n    this.refDistance = _.max([GAME_WIDTH, GAME_HEIGHT]) / 2 + 100;\n    this.refMarkers = [\n      this.add.sprite(0, 0, 'refMarkers'),\n      this.add.sprite(0, this.refDistance, 'refMarkers'),\n      this.add.sprite(this.refDistance, 0, 'refMarkers'),\n      this.add.sprite(this.refDistance, this.refDistance, 'refMarkers'),\n    ];\n    _.each(this.refMarkers, marker => marker.setScale(0.75));\n    this.skiBody = this.add.sprite(0, 0, 'skiBody');\n    this.leftSki = this.add.sprite(-40, 0, 'leftSki');\n    this.rightSki = this.add.sprite(40, 0, 'rightSki');\n    this.skiPlayer = this.add.container(\n      this.refDistance / 2,\n      this.refDistance / 2,\n      [this.skiBody, this.leftSki, this.rightSki]\n    );\n    this.skiPlayer.setScale(0.25);\n    this.physics.world.enable(this.skiPlayer);\n    this.edgeSnowParticles = this.add.particles('snowParticle');\n    this.edgeSnowEmitter = this.edgeSnowParticles.createEmitter({\n      radial: false,\n      lifespan: 375,\n      quantity: 5,\n      angle: { min: -100, max: -80 },\n      blendMode: 'ADD',\n      on: false,\n    });\n\n    // CAMERA\n    this.cameras.main.setBackgroundColor(0xf5f5f5);\n    this.cameras.main.startFollow(this.skiPlayer);\n\n    // CONTROLS\n    this.skiTurningCursors = this.input.keyboard.createCursorKeys();\n    this.skiTiltCursors = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D,\n    });\n  }\n\n  update() {\n    this.drawReferenceObjects();\n\n    if (!this.isCrashed) {\n      this.controlRotation();\n      this.controlTilt();\n      this.storeSkiPlayerValues();\n    }\n    this.drawRotationArrow();\n    this.drawVelocityArrow();\n\n    // ACCELERATION DUE TO GRAVITY\n    let accelerationDueToGravity = { x: 0, y: 0 };\n    if (!this.isCrashed) {\n      // acceleration lessened by the ground\n      const slopeFactor = Math.sin(this.slopeSteepness);\n      // acceleration is parallel to skis if they are tilted. otherwise\n      // acceleration is in direction of the slope.\n      const gravityAccelerationDirection = _.isNull(this.previousTiltDirection)\n        ? this.slopeDirection\n        : this.skiPlayer.rotation;\n      // acceleration lessened if acceleration not lined up with the slope\n      // direction\n      const traversalFactor = Math.cos(\n        gravityAccelerationDirection - this.slopeDirection\n      );\n      // slope and traversal factors scale the gravity constant to get the\n      // acceleration\n      const accelerationMagnitude =\n        this.gravityAccelerationConstant * slopeFactor * traversalFactor;\n      // split this acceleration into its x-y components\n      accelerationDueToGravity = {\n        x: Math.sin(gravityAccelerationDirection) * accelerationMagnitude,\n        y: -Math.cos(gravityAccelerationDirection) * accelerationMagnitude,\n      };\n    }\n\n    // DECELERATE DUE TO SKI EDGES\n    // acceleration decreases with velocity perpendicular to the skis\n    const velocityAngle = Math.atan2(\n      this.skiPlayer.body.velocity.x,\n      -this.skiPlayer.body.velocity.y\n    );\n    const skisPerpendicularLeft = this.skiPlayer.rotation - Math.PI / 2;\n    const skisPerpendicularRight = this.skiPlayer.rotation + Math.PI / 2;\n    const leftDiff = Math.abs(\n      smallestAngleDifference(skisPerpendicularLeft, velocityAngle)\n    );\n    const rightDiff = Math.abs(\n      smallestAngleDifference(skisPerpendicularRight, velocityAngle)\n    );\n    const skisPerpendicularAngle =\n      leftDiff < rightDiff ? skisPerpendicularLeft : skisPerpendicularRight;\n    const turnFactor = Math.cos(velocityAngle - skisPerpendicularAngle);\n    // turn factor scales the velocity to get the (negative) acceleration in the\n    // direction perpendicular to the skis\n    const skisPerpendicularSpeed = this.skiPlayer.body.speed * turnFactor;\n    // scale the acceleration by the amount the skis are tilted, with some\n    // scrape even when there's no tilt\n    const tiltFactor = 0.1 + this.previousTiltAmount * 0.9;\n    const skisPerpendicularAcceleration = -skisPerpendicularSpeed * tiltFactor;\n    // split this acceleration into its x-y components\n    const accelerationDueToEdges = {\n      x: Math.sin(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n      y: -Math.cos(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n    };\n\n    // APPLY NET ACCELERATION\n    const acceleration = {\n      x: accelerationDueToGravity.x + accelerationDueToEdges.x,\n      y: accelerationDueToGravity.y + accelerationDueToEdges.y,\n    };\n    this.skiPlayer.body.setAcceleration(acceleration.x, acceleration.y);\n\n    // SCRAPE EFFECTS\n    const snowEmissionSpeed = skisPerpendicularSpeed * 1.1;\n    const scrapeStrength = Math.abs(skisPerpendicularAcceleration);\n    const isScraping = scrapeStrength >= 100;\n    const isEmitterOn = this.edgeSnowEmitter.on;\n    if (isScraping) {\n      if (!isEmitterOn) {\n        this.edgeSnowEmitter.start();\n      }\n      // set the angle and speed of the snow emissions\n      const scrapeEdge =\n        skisPerpendicularAngle === skisPerpendicularLeft ? 'left' : 'right';\n      const skisBackCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getBottomLeft(null, true)\n          : this.skiBody.getBottomRight(null, true);\n      const skisFrontCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getTopLeft(null, true)\n          : this.skiBody.getTopRight(null, true);\n      const scrapingLine = new Phaser.Geom.Line(\n        skisBackCorner.x,\n        skisBackCorner.y,\n        skisFrontCorner.x,\n        skisFrontCorner.y\n      );\n      this.edgeSnowEmitter.setEmitZone({\n        source: scrapingLine,\n        type: 'random',\n      });\n      this.edgeSnowEmitter.setSpeed(snowEmissionSpeed);\n      // set the frequency and size of the snow emissions\n      const roundedScrapeStrength = Math.floor(scrapeStrength / 200) * 200;\n      const ceilingScrapeStrength = 1000;\n      const slowestEmitterFrequency = 50;\n      const fastestEmitterFrequency = 0;\n      const maxEmitterScale = 0.12;\n      const minEmitterScale = 0.05;\n      const maxEmitterQuantity = 10;\n      const minEmitterQuantity = 5;\n      let newEmitterFrequency;\n      let newEmitterScale;\n      let newEmitterQuantity;\n      if (roundedScrapeStrength >= ceilingScrapeStrength) {\n        newEmitterFrequency = fastestEmitterFrequency;\n        newEmitterScale = maxEmitterScale;\n        newEmitterQuantity = maxEmitterQuantity;\n      } else {\n        newEmitterFrequency =\n          slowestEmitterFrequency *\n          (1 - roundedScrapeStrength / ceilingScrapeStrength);\n        newEmitterScale = mapValBetween(\n          minEmitterScale,\n          maxEmitterScale,\n          roundedScrapeStrength / ceilingScrapeStrength\n        );\n        newEmitterQuantity = mapValBetween(\n          minEmitterQuantity,\n          maxEmitterQuantity,\n          roundedScrapeStrength / ceilingScrapeStrength\n        );\n      }\n      if (newEmitterFrequency !== this.edgeSnowEmitter.frequency) {\n        this.edgeSnowEmitter.setFrequency(newEmitterFrequency);\n        this.edgeSnowEmitter.setScale({ start: newEmitterScale, end: 0 });\n        this.edgeSnowEmitter.setQuantity(newEmitterQuantity);\n      }\n      // leave a trail in the snow\n      if (this.previousBackCorner) {\n        const graphics = this.add.graphics();\n        graphics.setDefaultStyles({\n          lineStyle: { width: 3, color: 0xcccccc },\n        });\n        const line = graphics.lineBetween(\n          this.previousBackCorner.x,\n          this.previousBackCorner.y,\n          skisBackCorner.x,\n          skisBackCorner.y\n        );\n        this.add.tween({\n          targets: [line],\n          duration: 1000,\n          alpha: 0,\n          onComplete() {\n            graphics.destroy();\n          },\n        });\n      }\n      this.previousBackCorner = skisBackCorner;\n\n      // fall off skis if tilting toward the scrape\n      if (scrapeEdge === this.previousTiltDirection) {\n        this.crash();\n      }\n    } else {\n      if (isEmitterOn) {\n        this.edgeSnowEmitter.stop();\n      }\n      this.previousBackCorner = null;\n    }\n  }\n\n  /* GAME HELPERS */\n\n  controlRotation() {\n    const maxAngularVelocity = Math.PI / 70;\n    const angularAcceleration = Math.PI / 1000;\n    const currentAngularVelocity = _.min([\n      this.previousAngularVelocity + angularAcceleration,\n      maxAngularVelocity,\n    ]);\n    if (this.skiTurningCursors.left.isDown) {\n      if (this.previousTurnDirection !== 'right') {\n        this.skiPlayer.rotation -= currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'left';\n    } else if (this.skiTurningCursors.right.isDown) {\n      if (this.previousTurnDirection !== 'left') {\n        this.skiPlayer.rotation += currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'right';\n    } else {\n      this.previousAngularVelocity = 0;\n      this.previousTurnDirection = null;\n    }\n  }\n\n  controlTilt() {\n    const maxSkisScale = 1;\n    const minSkisScale = 0.8;\n    const maxTilt = 1;\n    const minTilt = 0;\n    const tiltVelocity = 0.05;\n    let tiltAmount;\n    let tiltDirection = this.previousTiltDirection;\n    if (this.skiTiltCursors.left.isDown) {\n      if (this.previousTiltDirection !== 'right') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'left';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else if (this.skiTiltCursors.right.isDown) {\n      if (this.previousTiltDirection !== 'left') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'right';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else {\n      tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n    }\n    if (tiltAmount === 0) {\n      tiltDirection = null;\n    }\n    const skisScaleX =\n      maxSkisScale * (1 - tiltAmount) + minSkisScale * tiltAmount;\n    this.leftSki.setScale(skisScaleX, maxSkisScale);\n    this.rightSki.setScale(skisScaleX, maxSkisScale);\n    this.previousTiltAmount = tiltAmount;\n    this.previousTiltDirection = tiltDirection;\n  }\n\n  storeSkiPlayerValues() {\n    this.storedSkiPlayerPosition = { x: this.skiPlayer.x, y: this.skiPlayer.y };\n    this.storedSkiPlayerRotation = this.skiPlayer.rotation;\n    this.storedSkiPlayerVelocity = {\n      x: this.skiPlayer.body.velocity.x,\n      y: this.skiPlayer.body.velocity.y,\n    };\n    this.storedSkiPlayerSpeed = this.skiPlayer.body.speed;\n  }\n\n  drawRotationArrow() {\n    if (this.skisFacingArrowGraphics) {\n      this.skisFacingArrowGraphics.destroy();\n    }\n\n    const legendScene = this.scene.get('VectorLegend');\n    const vectorInfo = legendScene.vectorInfos['rotation'];\n    if (vectorInfo.on) {\n      const arrowLength = 120;\n      const start = {\n        x: this.storedSkiPlayerPosition.x,\n        y: this.storedSkiPlayerPosition.y,\n      };\n      const end = {\n        x: start.x + Math.sin(this.storedSkiPlayerRotation) * arrowLength,\n        y: start.y - Math.cos(this.storedSkiPlayerRotation) * arrowLength,\n      };\n      const color = vectorInfo.color;\n      this.skisFacingArrowGraphics = makeArrow({\n        scene: this,\n        start,\n        end,\n        color,\n      });\n    }\n  }\n\n  drawVelocityArrow() {\n    if (this.velocityArrowGraphics) {\n      this.velocityArrowGraphics.destroy();\n    }\n\n    const legendScene = this.scene.get('VectorLegend');\n    const vectorInfo = legendScene.vectorInfos['velocity'];\n    if (vectorInfo.on) {\n      const maxArrowLength = 250;\n      const mappedSpeed = mapInfToOne(this.storedSkiPlayerSpeed);\n      const arrowLength = maxArrowLength * mappedSpeed;\n      const arrowLengthX =\n        (this.storedSkiPlayerVelocity.x / this.storedSkiPlayerSpeed) *\n        arrowLength;\n      const arrowLengthY =\n        (this.storedSkiPlayerVelocity.y / this.storedSkiPlayerSpeed) *\n        arrowLength;\n      const start = {\n        x: this.storedSkiPlayerPosition.x,\n        y: this.storedSkiPlayerPosition.y,\n      };\n      const end = {\n        x: start.x + arrowLengthX,\n        y: start.y + arrowLengthY,\n      };\n      const color = vectorInfo.color;\n      this.velocityArrowGraphics = makeArrow({\n        scene: this,\n        start,\n        end,\n        color,\n      });\n    }\n  }\n\n  drawReferenceObjects() {\n    const closestBelow =\n      Math.floor(this.skiPlayer.y / this.refDistance) * this.refDistance;\n    const closestLeft =\n      Math.floor(this.skiPlayer.x / this.refDistance) * this.refDistance;\n    const needNewRefs =\n      this.refMarkers[0].x !== closestLeft ||\n      this.refMarkers[0].y !== closestBelow;\n    if (needNewRefs) {\n      const closestRight = closestLeft + this.refDistance;\n      const closestAbove = closestBelow + this.refDistance;\n      this.refMarkers[0].setPosition(closestLeft, closestBelow);\n      this.refMarkers[1].setPosition(closestLeft, closestAbove);\n      this.refMarkers[2].setPosition(closestRight, closestBelow);\n      this.refMarkers[3].setPosition(closestRight, closestAbove);\n    }\n  }\n\n  crash() {\n    this.isCrashed = true;\n    this.skiPlayer.body.setVelocity(0);\n    this.skiPlayer.body.setAcceleration(0);\n    this.leftSki.destroy();\n    this.rightSki.destroy();\n    this.crashedSkis = this.add.sprite(0, 0, 'crashedSkis');\n    this.skiPlayer.add(this.crashedSkis);\n    this.edgeSnowEmitter.setScale({ start: 1, end: 0 });\n    this.edgeSnowEmitter.setAngle({ min: 0, max: 360 });\n    this.edgeSnowEmitter.setLifespan(750);\n    this.edgeSnowEmitter.setSpeed(150);\n    this.edgeSnowEmitter.explode(30, 0, 0);\n    this.cameras.main.shake(300, 0.07);\n    this.events.emit('crash');\n  }\n}\n\nexport default MountainSlope;\n","import Phaser from 'phaser';\n\nimport { publicURL } from 'gameHelpers';\nimport { GAME_WIDTH, GAME_HEIGHT, GAME_PADDING } from 'gameConstants';\n\nclass LogoScene extends Phaser.Scene {\n  constructor() {\n    super({ key: 'LogoScene', active: true });\n  }\n\n  /* MAIN PHASER METHODS */\n\n  preload() {\n    this.load.image('logo', publicURL('/gameAssets/images/simulatorLogo.png'));\n  }\n\n  create() {\n    const logo = this.add.sprite(15, 15, 'logo');\n    logo.setOrigin(0, 0);\n    logo.setScale(0.5);\n  }\n}\n\nexport default LogoScene;\n","import _ from 'lodash';\nimport Phaser from 'phaser';\n\nimport { makeArrow } from 'gameHelpers';\nimport { GAME_WIDTH, GAME_PADDING } from 'gameConstants';\n\nclass VectorLegend extends Phaser.Scene {\n  constructor() {\n    super({ key: 'VectorLegend', active: true });\n  }\n\n  /* MAIN PHASER METHODS */\n\n  create() {\n    this.boxGraphics = {};\n    this.vectorInfos = {\n      rotation: {\n        key: 'rotation',\n        title: 'Ski Tips Pointing',\n        color: 0x3388aa,\n        on: false,\n        idx: 0,\n      },\n      velocity: {\n        key: 'velocity',\n        title: 'Velocity',\n        color: 0x33aa00,\n        on: false,\n        idx: 1,\n      },\n    };\n    _.each(this.vectorInfos, ({ key }) => {\n      this.drawLegendItem({ key });\n    });\n\n    const vectorsListHeader = this.add.text(\n      GAME_WIDTH - GAME_PADDING,\n      GAME_PADDING,\n      'Show Vectors',\n      {\n        color: '#444444',\n        fontSize: `${this.vectorsListTitleSize}px`,\n        fontStyle: 'bold',\n      }\n    );\n    vectorsListHeader.setOrigin(1, 0);\n  }\n\n  /* GAME HELPERS */\n\n  itemWidth = 100;\n\n  itemHeight = 50;\n\n  itemMargin = 26;\n\n  itemTitleSize = 14;\n\n  vectorsListTitleSize = 20;\n\n  drawLegendItem({ key }) {\n    const vectorInfo = this.vectorInfos[key];\n    const { x: centerX, y: centerY } = this.legendItemCenter(vectorInfo.idx);\n\n    // draw the box background and arrow\n    const graphics = this.add.graphics();\n    graphics.setDefaultStyles({ fillStyle: { color: 0xdddddd } });\n    graphics.fillRect(\n      centerX - this.itemWidth / 2,\n      centerY - this.itemHeight / 2,\n      this.itemWidth,\n      this.itemHeight\n    );\n    makeArrow({\n      scene: this,\n      start: { x: centerX - 30, y: centerY + 8 },\n      end: { x: centerX + 30, y: centerY - 8 },\n      color: vectorInfo.color,\n    });\n\n    // make the box clickable to show/hide the vector on the skis\n    const toggleButton = this.add.zone(\n      centerX,\n      centerY,\n      this.itemWidth,\n      this.itemHeight\n    );\n    toggleButton.setInteractive({ useHandCursor: true });\n    toggleButton.on('pointerup', () => {\n      vectorInfo.on = !vectorInfo.on;\n      this.drawLegendItemBorder({ key });\n    });\n\n    // title text\n    const textColor = `#${vectorInfo.color.toString(16)}`;\n    const legendItemText = this.add.text(\n      centerX + this.itemWidth / 2,\n      centerY - this.itemHeight / 2 - this.itemMargin / 2,\n      vectorInfo.title,\n      { color: textColor, fontSize: `${this.itemTitleSize}px` }\n    );\n    legendItemText.setOrigin(1, 0.5);\n  }\n\n  drawLegendItemBorder({ key }) {\n    const vectorInfo = this.vectorInfos[key];\n    const { x: centerX, y: centerY } = this.legendItemCenter(vectorInfo.idx);\n\n    // draw the box border\n    if (this.boxGraphics[key]) {\n      this.boxGraphics[key].destroy();\n    }\n    this.boxGraphics[key] = this.add.graphics();\n    this.boxGraphics[key].setDefaultStyles({\n      lineStyle: { width: 3, color: vectorInfo.color },\n    });\n    if (vectorInfo.on) {\n      this.boxGraphics[key].strokeRect(\n        centerX - this.itemWidth / 2,\n        centerY - this.itemHeight / 2,\n        this.itemWidth,\n        this.itemHeight\n      );\n    }\n  }\n\n  legendItemCenter = idx => {\n    return {\n      x: GAME_WIDTH - GAME_PADDING - this.itemWidth / 2,\n      y:\n        GAME_PADDING +\n        this.vectorsListTitleSize +\n        10 +\n        this.itemMargin +\n        (this.itemMargin + this.itemHeight) * idx +\n        this.itemHeight / 2,\n    };\n  };\n}\n\nexport default VectorLegend;\n","import Phaser from 'phaser';\n\nimport { publicURL } from 'gameHelpers';\nimport { GAME_WIDTH, GAME_HEIGHT, GAME_PADDING } from 'gameConstants';\n\nclass SkiTiltDisplay extends Phaser.Scene {\n  constructor() {\n    super({ key: 'SkiTiltDisplay', active: true });\n  }\n\n  /* MAIN PHASER METHODS */\n\n  preload() {\n    this.load.image(\n      'leftSkiBack',\n      publicURL('/gameAssets/images/leftSkiBack.png')\n    );\n    this.load.image(\n      'rightSkiBack',\n      publicURL('/gameAssets/images/rightSkiBack.png')\n    );\n  }\n\n  create() {\n    const displayWidth = 240;\n    const displayHeight = 110;\n    const displayCenterX = GAME_WIDTH - GAME_PADDING - displayWidth / 2;\n    const displayCenterY = GAME_HEIGHT - GAME_PADDING - displayHeight / 2;\n\n    const graphics = this.add.graphics();\n    graphics.setDefaultStyles({\n      lineStyle: { width: 3, color: 0x777777 },\n      fillStyle: { color: 0xdddddd },\n    });\n    graphics.fillRect(\n      displayCenterX - displayWidth / 2,\n      displayCenterY - displayHeight / 2,\n      displayWidth,\n      displayHeight\n    );\n    graphics.strokeRect(\n      displayCenterX - displayWidth / 2,\n      displayCenterY - displayHeight / 2,\n      displayWidth,\n      displayHeight\n    );\n\n    this.leftSki = this.add.sprite(-220, 0, 'leftSkiBack');\n    this.rightSki = this.add.sprite(220, 0, 'rightSkiBack');\n    this.skis = this.add.container(displayCenterX, displayCenterY, [\n      this.leftSki,\n      this.rightSki,\n    ]);\n    this.skis.setScale(0.23);\n\n    const titleText = this.add.text(\n      displayCenterX + displayWidth / 2,\n      displayCenterY - displayHeight / 2 - 5,\n      'Tilt (view from behind skis)',\n      { color: '#555555', fontSize: '16px' }\n    );\n    titleText.setOrigin(1, 1);\n  }\n\n  update() {\n    const slopeScene = this.scene.get('MountainSlope');\n    const {\n      previousTiltAmount: tiltAmount,\n      previousTiltDirection: tiltDirection,\n    } = slopeScene;\n    const minRotation = 0;\n    const maxRotation = Math.PI / 4;\n    const tiltRotationSign = tiltDirection === 'left' ? -1 : 1;\n    const tiltRotationMagnitude =\n      minRotation * (1 - tiltAmount) + maxRotation * tiltAmount;\n    const tiltRotation = tiltRotationMagnitude * tiltRotationSign;\n    this.leftSki.rotation = tiltRotation;\n    this.rightSki.rotation = tiltRotation;\n  }\n}\n\nexport default SkiTiltDisplay;\n","import _ from 'lodash';\nimport Phaser from 'phaser';\n\nimport { GAME_WIDTH, GAME_HEIGHT, GAME_PADDING } from 'gameConstants';\n\nclass ResetButton extends Phaser.Scene {\n  constructor() {\n    super({ key: 'ResetButton', active: true });\n  }\n\n  create() {\n    const displayWidth = 320;\n    const displayHeight = 160;\n    const displayCenterX = GAME_WIDTH / 2;\n    const displayCenterY = GAME_HEIGHT - GAME_PADDING - displayHeight / 2;\n\n    const graphics = this.add.graphics();\n    graphics.setDefaultStyles({\n      lineStyle: { width: 8, color: 0x44aa44 },\n      fillStyle: { color: 0x88dd88 },\n    });\n\n    const slopeScene = this.scene.get('MountainSlope');\n    slopeScene.events.on('crash', () => {\n      const rectArgs = [\n        displayCenterX - displayWidth / 2,\n        displayCenterY - displayHeight / 2,\n        displayWidth,\n        displayHeight,\n        5,\n      ];\n      graphics.strokeRoundedRect(...rectArgs);\n      graphics.fillRoundedRect(...rectArgs);\n      const resetButtonText = this.add.text(\n        displayCenterX,\n        displayCenterY,\n        'Lift Back Up',\n        { color: '#117711', fontSize: '28px', fontStyle: 'bold' }\n      );\n      resetButtonText.setOrigin(0.5, 0.5);\n      const resetButton = this.add.zone(\n        displayCenterX,\n        displayCenterY,\n        displayWidth,\n        displayHeight\n      );\n      resetButton.setInteractive({ useHandCursor: true });\n      resetButton.on('pointerup', () => {\n        _.each(this.scene.manager.scenes, scene => scene.scene.restart());\n      });\n    });\n  }\n}\n\nexport default ResetButton;\n","import React, { Component } from 'react';\n\nimport { initializeGame } from 'game';\nimport 'stylesheets/components/app/app.css';\n\nclass App extends Component {\n  containerId = 'game-container';\n\n  componentDidMount() {\n    initializeGame({ parent: this.containerId });\n  }\n\n  render() {\n    return (\n      <div className=\"app\">\n        <div id={this.containerId} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import Phaser from 'phaser';\n\nimport { GAME_WIDTH, GAME_HEIGHT } from 'gameConstants';\nimport MountainSlope from 'gameScenes/mountainSlope';\nimport LogoScene from 'gameScenes/logoScene';\nimport VectorLegend from 'gameScenes/vectorLegend';\nimport SkiTiltDisplay from 'gameScenes/skiTiltDisplay';\nimport ResetButton from 'gameScenes/resetButton';\n\nexport const initializeGame = ({ parent }) => {\n  const gameConfig = {\n    width: GAME_WIDTH,\n    height: GAME_HEIGHT,\n    scene: [\n      MountainSlope,\n      LogoScene,\n      VectorLegend,\n      SkiTiltDisplay,\n      ResetButton,\n    ],\n    physics: {\n      default: 'arcade',\n    },\n    type: Phaser.AUTO,\n    parent,\n  };\n  const game = new Phaser.Game(gameConfig);\n  return game;\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'stylesheets/index.css';\nimport App from './components/app/app';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}