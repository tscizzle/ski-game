{"version":3,"sources":["game.js","components/app/app.js","serviceWorker.js","index.js"],"names":["SkiSlope","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","publicURL","path","concat","process","smallestAngleDifference","a","b","Math","atan2","sin","cos","console","log","load","image","slopeSteepness","PI","slopeDirection","gravityAccelerationConstant","previousAngularVelocity","previousTurnDirection","previousTiltAmount","previousTiltDirection","previousBackCorner","standingOnSkis","refArrows","add","sprite","_","each","arrow","setScale","skiBody","leftSki","rightSki","skiPlayer","container","physics","world","enable","edgeSnowParticles","particles","edgeSnowEmitter","createEmitter","radial","lifespan","blendMode","on","cameras","main","setBackgroundColor","startFollow","skiTurningCursors","input","keyboard","createCursorKeys","skiTiltCursors","addKeys","up","Phaser","Input","Keyboard","KeyCodes","W","down","S","left","A","right","D","maxAngularVelocity","angularAcceleration","currentAngularVelocity","min","isDown","rotation","tiltAmount","tiltDirection","max","skisScaleX","slopeFactor","gravityAccelerationDirection","isNull","traversalFactor","accelerationMagnitude","accelerationDueToGravity","velocityAngle","body","velocity","x","y","skisPerpendicularLeft","skisPerpendicularRight","skisPerpendicularAngle","abs","turnFactor","skisPerpendicularSpeed","speed","skisPerpendicularAcceleration","acceleration","setAcceleration","closestBelow","floor","closestLeft","closestRight","closestAbove","setPosition","snowEmissionSpeed","scrapeStrength","isScraping","isEmitterOn","start","scrapeEdge","skisBackCorner","getBottomLeft","getBottomRight","skisFrontCorner","getTopLeft","getTopRight","scrapingLine","Geom","Line","setEmitZone","source","type","setSpeed","setAngle","newEmitterFrequency","newEmitterScale","roundedScrapeStrength","frequency","setFrequency","end","graphics","setDefaultStyles","lineStyle","width","color","line","lineBetween","tween","targets","duration","alpha","onComplete","destroy","stop","setVelocity","Scene","App","gameConfig","AUTO","height","scene","default","Game","initializeGame","react_default","createElement","className","Component","Boolean","window","location","hostname","match","ReactDOM","render","app_app","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.72707cc7.chunk.js","sourcesContent":["import _ from 'lodash';\nimport Phaser from 'phaser';\n\nclass SkiSlope extends Phaser.Scene {\n  constructor() {\n    super('SkiSlope');\n  }\n\n  preload() {\n    console.log('HOF');\n    console.log(this.publicURL(''));\n    console.log('BOOGA');\n    this.load.image(\n      'arrows',\n      this.publicURL('gameAssets/images/racingArrows.png')\n    );\n    this.load.image('skiBody', this.publicURL('gameAssets/images/skiBody.png'));\n    this.load.image('leftSki', this.publicURL('gameAssets/images/leftSki.png'));\n    this.load.image(\n      'rightSki',\n      this.publicURL('gameAssets/images/rightSki.png')\n    );\n    this.load.image(\n      'snowParticle',\n      this.publicURL('gameAssets/images/snowParticle.png')\n    );\n  }\n\n  create() {\n    // INITIALIZE CONSTANTS\n    this.slopeSteepness = Math.PI / 6; // angle with ground\n    this.slopeDirection = 0; // angle rotated clockwise from forward\n    this.gravityAccelerationConstant = 500;\n\n    // INITIALIZE VALUES THAT GET UPDATED\n    this.previousAngularVelocity = 0;\n    this.previousTurnDirection = null;\n    this.previousTiltAmount = 0;\n    this.previousTiltDirection = null;\n    this.previousBackCorner = null;\n    this.standingOnSkis = true;\n\n    // VISUAL OBJECTS\n    this.refArrows = [\n      this.add.sprite(0, 0, 'arrows'),\n      this.add.sprite(0, 500, 'arrows'),\n      this.add.sprite(500, 0, 'arrows'),\n      this.add.sprite(500, 500, 'arrows'),\n    ];\n    _.each(this.refArrows, arrow => arrow.setScale(0.75));\n    this.skiBody = this.add.sprite(0, 0, 'skiBody');\n    this.leftSki = this.add.sprite(-40, 0, 'leftSki');\n    this.rightSki = this.add.sprite(40, 0, 'rightSki');\n    this.skiPlayer = this.add.container(250, 250, [\n      this.skiBody,\n      this.leftSki,\n      this.rightSki,\n    ]);\n    this.skiPlayer.setScale(0.25);\n    this.physics.world.enable(this.skiPlayer);\n    this.edgeSnowParticles = this.add.particles('snowParticle');\n    this.edgeSnowEmitter = this.edgeSnowParticles.createEmitter({\n      radial: false,\n      lifespan: 400,\n      blendMode: 'ADD',\n      on: false,\n    });\n\n    // CAMERA\n    this.cameras.main.setBackgroundColor(0xf0f0f0);\n    this.cameras.main.startFollow(this.skiPlayer);\n\n    // CONTROLS\n    this.skiTurningCursors = this.input.keyboard.createCursorKeys();\n    this.skiTiltCursors = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D,\n    });\n\n    // this.scene.pause();\n  }\n\n  update() {\n    // CONTROL ROTATION\n    const maxAngularVelocity = Math.PI / 70;\n    const angularAcceleration = Math.PI / 1000;\n    const currentAngularVelocity = _.min([\n      this.previousAngularVelocity + angularAcceleration,\n      maxAngularVelocity,\n    ]);\n    if (this.skiTurningCursors.left.isDown) {\n      if (this.previousTurnDirection !== 'right') {\n        this.skiPlayer.rotation -= currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'left';\n    } else if (this.skiTurningCursors.right.isDown) {\n      if (this.previousTurnDirection !== 'left') {\n        this.skiPlayer.rotation += currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'right';\n    } else {\n      this.previousAngularVelocity = 0;\n      this.previousTurnDirection = null;\n    }\n\n    // CONTROL TILT\n    const maxSkisScale = 1;\n    const minSkisScale = 0.8;\n    const maxTilt = 1;\n    const minTilt = 0;\n    const tiltVelocity = 0.05;\n    let tiltAmount;\n    let tiltDirection = this.previousTiltDirection;\n    if (this.skiTiltCursors.left.isDown) {\n      if (this.previousTiltDirection !== 'right') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'left';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else if (this.skiTiltCursors.right.isDown) {\n      if (this.previousTiltDirection !== 'left') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'right';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else {\n      tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n    }\n    if (tiltAmount === 0) {\n      tiltDirection = null;\n    }\n    const skisScaleX =\n      maxSkisScale * (1 - tiltAmount) + minSkisScale * tiltAmount;\n    this.leftSki.setScale(skisScaleX, maxSkisScale);\n    this.rightSki.setScale(skisScaleX, maxSkisScale);\n    this.previousTiltAmount = tiltAmount;\n    this.previousTiltDirection = tiltDirection;\n\n    // ACCELERATE DUE TO GRAVITY\n    // acceleration lessened by the ground\n    const slopeFactor = Math.sin(this.slopeSteepness);\n    // acceleration is parallel to skis if they are tilted. otherwise\n    // acceleration is in direction of the slope.\n    const gravityAccelerationDirection = _.isNull(tiltDirection)\n      ? this.slopeDirection\n      : this.skiPlayer.rotation;\n    // acceleration lessened if acceleration not lined up with the slope\n    // direction\n    const traversalFactor = Math.cos(\n      gravityAccelerationDirection - this.slopeDirection\n    );\n    // slope and traversal factors scale the gravity constant to get the\n    // acceleration\n    const accelerationMagnitude =\n      this.gravityAccelerationConstant * slopeFactor * traversalFactor;\n    // split this acceleration into its x-y components\n    const accelerationDueToGravity = {\n      x: Math.sin(gravityAccelerationDirection) * accelerationMagnitude,\n      y: -Math.cos(gravityAccelerationDirection) * accelerationMagnitude,\n    };\n\n    // DECELERATE DUE TO SKI EDGES\n    // acceleration decreases with velocity perpendicular to the skis\n    const velocityAngle = Math.atan2(\n      this.skiPlayer.body.velocity.x,\n      -this.skiPlayer.body.velocity.y\n    );\n    const skisPerpendicularLeft = this.skiPlayer.rotation - Math.PI / 2;\n    const skisPerpendicularRight = this.skiPlayer.rotation + Math.PI / 2;\n    const leftDiff = Math.abs(\n      this.smallestAngleDifference(skisPerpendicularLeft, velocityAngle)\n    );\n    const rightDiff = Math.abs(\n      this.smallestAngleDifference(skisPerpendicularRight, velocityAngle)\n    );\n    const skisPerpendicularAngle =\n      leftDiff < rightDiff ? skisPerpendicularLeft : skisPerpendicularRight;\n    const turnFactor = Math.cos(velocityAngle - skisPerpendicularAngle);\n    // turn factor scales the velocity to get the (negative) acceleration in the\n    // direction perpendicular to the skis\n    const skisPerpendicularSpeed = this.skiPlayer.body.speed * turnFactor;\n    // scale the acceleration by the amount the skis are tilted, with some\n    // scrape even when there's no tilt\n    const tiltFactor = 0.1 + tiltAmount * 0.9;\n    const skisPerpendicularAcceleration = -skisPerpendicularSpeed * tiltFactor;\n    // split this acceleration into its x-y components\n    const accelerationDueToEdging = {\n      x: Math.sin(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n      y: -Math.cos(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n    };\n\n    // APPLY NET ACCELERATION\n    const acceleration = {\n      x: accelerationDueToGravity.x + accelerationDueToEdging.x,\n      y: accelerationDueToGravity.y + accelerationDueToEdging.y,\n    };\n    this.skiPlayer.body.setAcceleration(acceleration.x, acceleration.y);\n\n    // DRAW REFERENCE OBJECTS\n    const refDistance = 500;\n    const closestBelow =\n      Math.floor(this.skiPlayer.y / refDistance) * refDistance;\n    const closestLeft =\n      Math.floor(this.skiPlayer.x / refDistance) * refDistance;\n    const needNewRefs =\n      this.refArrows[0].x !== closestLeft ||\n      this.refArrows[0].y !== closestBelow;\n    if (needNewRefs) {\n      const closestRight = closestLeft + refDistance;\n      const closestAbove = closestBelow + refDistance;\n      this.refArrows[0].setPosition(closestLeft, closestBelow);\n      this.refArrows[1].setPosition(closestLeft, closestAbove);\n      this.refArrows[2].setPosition(closestRight, closestBelow);\n      this.refArrows[3].setPosition(closestRight, closestAbove);\n    }\n\n    // SCRAPE EFFECTS\n    const snowEmissionSpeed = skisPerpendicularSpeed * 1.1;\n    const scrapeStrength = Math.abs(skisPerpendicularAcceleration);\n    const isScraping = scrapeStrength >= 100;\n    const isEmitterOn = this.edgeSnowEmitter.on;\n    if (isScraping) {\n      if (!isEmitterOn) {\n        this.edgeSnowEmitter.start();\n      }\n      // set the angle and speed of the snow emissions\n      const scrapeEdge =\n        skisPerpendicularAngle === skisPerpendicularLeft ? 'left' : 'right';\n      const skisBackCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getBottomLeft(null, true)\n          : this.skiBody.getBottomRight(null, true);\n      const skisFrontCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getTopLeft(null, true)\n          : this.skiBody.getTopRight(null, true);\n      const scrapingLine = new Phaser.Geom.Line(\n        skisBackCorner.x,\n        skisBackCorner.y,\n        skisFrontCorner.x,\n        skisFrontCorner.y\n      );\n      this.edgeSnowEmitter.setEmitZone({\n        source: scrapingLine,\n        type: 'random',\n      });\n      this.edgeSnowEmitter.setSpeed(snowEmissionSpeed);\n      this.edgeSnowEmitter.setAngle(-90);\n      // set the frequency and size of the snow emissions\n      const roundedScrapeStrength = Math.floor(scrapeStrength / 200) * 200;\n      const ceilingScrapeStrength = 1000;\n      const slowestEmitterFrequency = 50;\n      const fastestEmitterFrequency = 0;\n      const maxEmitterScale = 0.25;\n      const minEmitterScale = 0.05;\n      let newEmitterFrequency;\n      let newEmitterScale;\n      if (roundedScrapeStrength >= ceilingScrapeStrength) {\n        newEmitterFrequency = fastestEmitterFrequency;\n        newEmitterScale = maxEmitterScale;\n      } else {\n        newEmitterFrequency =\n          slowestEmitterFrequency *\n          (1 - roundedScrapeStrength / ceilingScrapeStrength);\n        newEmitterScale =\n          (maxEmitterScale - minEmitterScale) *\n            (roundedScrapeStrength / ceilingScrapeStrength) +\n          minEmitterScale;\n      }\n      if (newEmitterFrequency !== this.edgeSnowEmitter.frequency) {\n        this.edgeSnowEmitter.setFrequency(newEmitterFrequency);\n        this.edgeSnowEmitter.setScale({ start: newEmitterScale, end: 0 });\n      }\n      // leave a trail in the snow\n      if (this.previousBackCorner) {\n        const graphics = this.add.graphics();\n        graphics.setDefaultStyles({ lineStyle: { width: 3, color: 0xcccccc } });\n        const line = graphics.lineBetween(\n          this.previousBackCorner.x,\n          this.previousBackCorner.y,\n          skisBackCorner.x,\n          skisBackCorner.y\n        );\n        this.add.tween({\n          targets: [line],\n          duration: 1000,\n          alpha: 0,\n          onComplete() {\n            line.destroy();\n            graphics.destroy();\n          },\n        });\n      }\n      this.previousBackCorner = skisBackCorner;\n\n      // fall off skis if tilting toward the scrape\n      if (scrapeEdge === tiltDirection) {\n        this.standingOnSkis = false;\n      }\n    } else {\n      if (isEmitterOn) {\n        this.edgeSnowEmitter.stop();\n      }\n      this.previousBackCorner = null;\n    }\n\n    // CRASH IF NO LONGER ON SKIS\n    if (!this.standingOnSkis) {\n      this.skiPlayer.body.setVelocity(0);\n      this.skiPlayer.body.setAcceleration(0);\n    }\n  }\n\n  /* HELPERS */\n\n  publicURL = path => `${process.env.PUBLIC_URL}${path}`;\n\n  smallestAngleDifference = (a, b) => {\n    return Math.atan2(Math.sin(a - b), Math.cos(a - b));\n  };\n}\n\nexport const initializeGame = () => {\n  const gameConfig = {\n    type: Phaser.AUTO,\n    width: 800,\n    height: 800,\n    scene: [SkiSlope],\n    physics: {\n      default: 'arcade',\n    },\n  };\n  const game = new Phaser.Game(gameConfig);\n  return game;\n};\n","import React, { Component } from 'react';\n\nimport { initializeGame } from 'game';\nimport 'stylesheets/components/app/app.css';\n\nclass App extends Component {\n  componentDidMount() {\n    initializeGame();\n  }\n\n  render() {\n    return <div className=\"app\" />;\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'stylesheets/index.css';\nimport App from './components/app/app';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}