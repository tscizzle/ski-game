{"version":3,"sources":["game.js","components/app/app.js","serviceWorker.js","index.js"],"names":["GAME_WIDTH","_","max","window","innerWidth","GAME_HEIGHT","innerHeight","console","log","MountainSlope","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","load","image","publicURL","slopeSteepness","Math","PI","slopeDirection","gravityAccelerationConstant","previousAngularVelocity","previousTurnDirection","previousTiltAmount","previousTiltDirection","previousBackCorner","isCrashed","refDistance","refArrows","add","sprite","each","arrow","setScale","skiBody","leftSki","rightSki","skiPlayer","container","physics","world","enable","edgeSnowParticles","particles","edgeSnowEmitter","createEmitter","radial","lifespan","quantity","angle","min","blendMode","on","cameras","main","setBackgroundColor","startFollow","skiTurningCursors","input","keyboard","createCursorKeys","skiTiltCursors","addKeys","up","Phaser","Input","Keyboard","KeyCodes","W","down","S","left","A","right","D","drawReferenceObjects","controlRotation","controlTilt","accelerationDueToGravity","x","y","slopeFactor","sin","gravityAccelerationDirection","isNull","rotation","traversalFactor","cos","accelerationMagnitude","velocityAngle","atan2","body","velocity","skisPerpendicularLeft","skisPerpendicularRight","skisPerpendicularAngle","abs","smallestAngleDifference","turnFactor","skisPerpendicularSpeed","speed","skisPerpendicularAcceleration","accelerationDueToEdges","acceleration","setAcceleration","snowEmissionSpeed","scrapeStrength","isScraping","isEmitterOn","start","scrapeEdge","skisBackCorner","getBottomLeft","getBottomRight","skisFrontCorner","getTopLeft","getTopRight","scrapingLine","Geom","Line","setEmitZone","source","type","setSpeed","newEmitterFrequency","newEmitterScale","roundedScrapeStrength","floor","frequency","setFrequency","end","graphics","setDefaultStyles","lineStyle","width","color","line","lineBetween","tween","targets","duration","alpha","onComplete","destroy","crash","stop","maxAngularVelocity","angularAcceleration","currentAngularVelocity","isDown","tiltAmount","tiltDirection","skisScaleX","closestBelow","closestLeft","closestRight","closestAbove","setPosition","setVelocity","crashedSkis","setAngle","setLifespan","explode","shake","Scene","SkiTiltDisplay","key","active","displayCenterX","displayWidth","displayCenterY","displayHeight","fillStyle","strokeRect","fillRect","skis","slopeScene","scene","get","tiltRotation","path","concat","process","a","b","App","gameConfig","height","default","AUTO","parent","Game","initializeGame","react_default","createElement","className","id","Component","Boolean","location","hostname","match","ReactDOM","render","app_app","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.97d0c587.chunk.js","sourcesContent":["import _ from 'lodash';\nimport Phaser from 'phaser';\n\nconst GAME_WIDTH = _.max([window.innerWidth - 6, 1200]);\nconst GAME_HEIGHT = _.max([window.innerHeight - 6, 800]);\nconsole.log(GAME_WIDTH, GAME_HEIGHT);\n\nclass MountainSlope extends Phaser.Scene {\n  constructor() {\n    super('MountainSlope');\n  }\n\n  /* MAIN PHASER METHODS */\n\n  preload() {\n    this.load.image('arrows', publicURL('/gameAssets/images/racingArrows.png'));\n    this.load.image('skiBody', publicURL('/gameAssets/images/skiBody.png'));\n    this.load.image('leftSki', publicURL('/gameAssets/images/leftSki.png'));\n    this.load.image('rightSki', publicURL('/gameAssets/images/rightSki.png'));\n    this.load.image(\n      'snowParticle',\n      publicURL('/gameAssets/images/snowParticle.png')\n    );\n    this.load.image(\n      'crashedSkis',\n      publicURL('/gameAssets/images/crashedSkis.png')\n    );\n  }\n\n  create() {\n    // INITIALIZE CONSTANTS\n    this.slopeSteepness = Math.PI / 6; // angle with ground\n    this.slopeDirection = 0; // angle rotated clockwise from forward\n    this.gravityAccelerationConstant = 500;\n\n    // INITIALIZE VALUES THAT GET UPDATED\n    this.previousAngularVelocity = 0;\n    this.previousTurnDirection = null;\n    this.previousTiltAmount = 0;\n    this.previousTiltDirection = null;\n    this.previousBackCorner = null;\n    this.isCrashed = false;\n\n    // VISUAL OBJECTS\n    this.refDistance = GAME_WIDTH / 2 + 100;\n    this.refArrows = [\n      this.add.sprite(0, 0, 'arrows'),\n      this.add.sprite(0, this.refDistance, 'arrows'),\n      this.add.sprite(this.refDistance, 0, 'arrows'),\n      this.add.sprite(this.refDistance, this.refDistance, 'arrows'),\n    ];\n    _.each(this.refArrows, arrow => arrow.setScale(0.75));\n    this.skiBody = this.add.sprite(0, 0, 'skiBody');\n    this.leftSki = this.add.sprite(-40, 0, 'leftSki');\n    this.rightSki = this.add.sprite(40, 0, 'rightSki');\n    this.skiPlayer = this.add.container(\n      this.refDistance / 2,\n      this.refDistance / 2,\n      [this.skiBody, this.leftSki, this.rightSki]\n    );\n    this.skiPlayer.setScale(0.25);\n    this.physics.world.enable(this.skiPlayer);\n    this.edgeSnowParticles = this.add.particles('snowParticle');\n    this.edgeSnowEmitter = this.edgeSnowParticles.createEmitter({\n      radial: false,\n      lifespan: 375,\n      quantity: 5,\n      angle: { min: -100, max: -80 },\n      blendMode: 'ADD',\n      on: false,\n    });\n\n    // CAMERA\n    this.cameras.main.setBackgroundColor(0xf0f0f0);\n    this.cameras.main.startFollow(this.skiPlayer);\n\n    // CONTROLS\n    this.skiTurningCursors = this.input.keyboard.createCursorKeys();\n    this.skiTiltCursors = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D,\n    });\n\n    // this.scene.pause();\n  }\n\n  update() {\n    this.drawReferenceObjects();\n\n    if (!this.isCrashed) {\n      this.controlRotation();\n      this.controlTilt();\n    }\n\n    // ACCELERATION DUE TO GRAVITY\n    let accelerationDueToGravity = { x: 0, y: 0 };\n    if (!this.isCrashed) {\n      // acceleration lessened by the ground\n      const slopeFactor = Math.sin(this.slopeSteepness);\n      // acceleration is parallel to skis if they are tilted. otherwise\n      // acceleration is in direction of the slope.\n      const gravityAccelerationDirection = _.isNull(this.previousTiltDirection)\n        ? this.slopeDirection\n        : this.skiPlayer.rotation;\n      // acceleration lessened if acceleration not lined up with the slope\n      // direction\n      const traversalFactor = Math.cos(\n        gravityAccelerationDirection - this.slopeDirection\n      );\n      // slope and traversal factors scale the gravity constant to get the\n      // acceleration\n      const accelerationMagnitude =\n        this.gravityAccelerationConstant * slopeFactor * traversalFactor;\n      // split this acceleration into its x-y components\n      accelerationDueToGravity = {\n        x: Math.sin(gravityAccelerationDirection) * accelerationMagnitude,\n        y: -Math.cos(gravityAccelerationDirection) * accelerationMagnitude,\n      };\n    }\n\n    // DECELERATE DUE TO SKI EDGES\n    // acceleration decreases with velocity perpendicular to the skis\n    const velocityAngle = Math.atan2(\n      this.skiPlayer.body.velocity.x,\n      -this.skiPlayer.body.velocity.y\n    );\n    const skisPerpendicularLeft = this.skiPlayer.rotation - Math.PI / 2;\n    const skisPerpendicularRight = this.skiPlayer.rotation + Math.PI / 2;\n    const leftDiff = Math.abs(\n      smallestAngleDifference(skisPerpendicularLeft, velocityAngle)\n    );\n    const rightDiff = Math.abs(\n      smallestAngleDifference(skisPerpendicularRight, velocityAngle)\n    );\n    const skisPerpendicularAngle =\n      leftDiff < rightDiff ? skisPerpendicularLeft : skisPerpendicularRight;\n    const turnFactor = Math.cos(velocityAngle - skisPerpendicularAngle);\n    // turn factor scales the velocity to get the (negative) acceleration in the\n    // direction perpendicular to the skis\n    const skisPerpendicularSpeed = this.skiPlayer.body.speed * turnFactor;\n    // scale the acceleration by the amount the skis are tilted, with some\n    // scrape even when there's no tilt\n    const tiltFactor = 0.1 + this.previousTiltAmount * 0.9;\n    const skisPerpendicularAcceleration = -skisPerpendicularSpeed * tiltFactor;\n    // split this acceleration into its x-y components\n    const accelerationDueToEdges = {\n      x: Math.sin(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n      y: -Math.cos(skisPerpendicularAngle) * skisPerpendicularAcceleration,\n    };\n\n    // APPLY NET ACCELERATION\n    const acceleration = {\n      x: accelerationDueToGravity.x + accelerationDueToEdges.x,\n      y: accelerationDueToGravity.y + accelerationDueToEdges.y,\n    };\n    this.skiPlayer.body.setAcceleration(acceleration.x, acceleration.y);\n\n    // SCRAPE EFFECTS\n    const snowEmissionSpeed = skisPerpendicularSpeed * 1.1;\n    const scrapeStrength = Math.abs(skisPerpendicularAcceleration);\n    const isScraping = scrapeStrength >= 100;\n    const isEmitterOn = this.edgeSnowEmitter.on;\n    if (isScraping) {\n      if (!isEmitterOn) {\n        this.edgeSnowEmitter.start();\n      }\n      // set the angle and speed of the snow emissions\n      const scrapeEdge =\n        skisPerpendicularAngle === skisPerpendicularLeft ? 'left' : 'right';\n      const skisBackCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getBottomLeft(null, true)\n          : this.skiBody.getBottomRight(null, true);\n      const skisFrontCorner =\n        scrapeEdge === 'left'\n          ? this.skiBody.getTopLeft(null, true)\n          : this.skiBody.getTopRight(null, true);\n      const scrapingLine = new Phaser.Geom.Line(\n        skisBackCorner.x,\n        skisBackCorner.y,\n        skisFrontCorner.x,\n        skisFrontCorner.y\n      );\n      this.edgeSnowEmitter.setEmitZone({\n        source: scrapingLine,\n        type: 'random',\n      });\n      this.edgeSnowEmitter.setSpeed(snowEmissionSpeed);\n      // set the frequency and size of the snow emissions\n      const roundedScrapeStrength = Math.floor(scrapeStrength / 200) * 200;\n      const ceilingScrapeStrength = 1000;\n      const slowestEmitterFrequency = 50;\n      const fastestEmitterFrequency = 0;\n      const maxEmitterScale = 0.25;\n      const minEmitterScale = 0.05;\n      let newEmitterFrequency;\n      let newEmitterScale;\n      if (roundedScrapeStrength >= ceilingScrapeStrength) {\n        newEmitterFrequency = fastestEmitterFrequency;\n        newEmitterScale = maxEmitterScale;\n      } else {\n        newEmitterFrequency =\n          slowestEmitterFrequency *\n          (1 - roundedScrapeStrength / ceilingScrapeStrength);\n        newEmitterScale =\n          (maxEmitterScale - minEmitterScale) *\n            (roundedScrapeStrength / ceilingScrapeStrength) +\n          minEmitterScale;\n      }\n      if (newEmitterFrequency !== this.edgeSnowEmitter.frequency) {\n        this.edgeSnowEmitter.setFrequency(newEmitterFrequency);\n        this.edgeSnowEmitter.setScale({ start: newEmitterScale, end: 0 });\n      }\n      // leave a trail in the snow\n      if (this.previousBackCorner) {\n        const graphics = this.add.graphics();\n        graphics.setDefaultStyles({ lineStyle: { width: 3, color: 0xcccccc } });\n        const line = graphics.lineBetween(\n          this.previousBackCorner.x,\n          this.previousBackCorner.y,\n          skisBackCorner.x,\n          skisBackCorner.y\n        );\n        this.add.tween({\n          targets: [line],\n          duration: 1000,\n          alpha: 0,\n          onComplete() {\n            line.destroy();\n            graphics.destroy();\n          },\n        });\n      }\n      this.previousBackCorner = skisBackCorner;\n\n      // fall off skis if tilting toward the scrape\n      if (scrapeEdge === this.previousTiltDirection) {\n        this.crash();\n      }\n    } else {\n      if (isEmitterOn) {\n        this.edgeSnowEmitter.stop();\n      }\n      this.previousBackCorner = null;\n    }\n  }\n\n  /* GAME HELPERS */\n\n  controlRotation() {\n    const maxAngularVelocity = Math.PI / 70;\n    const angularAcceleration = Math.PI / 1000;\n    const currentAngularVelocity = _.min([\n      this.previousAngularVelocity + angularAcceleration,\n      maxAngularVelocity,\n    ]);\n    if (this.skiTurningCursors.left.isDown) {\n      if (this.previousTurnDirection !== 'right') {\n        this.skiPlayer.rotation -= currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'left';\n    } else if (this.skiTurningCursors.right.isDown) {\n      if (this.previousTurnDirection !== 'left') {\n        this.skiPlayer.rotation += currentAngularVelocity;\n        this.previousAngularVelocity = currentAngularVelocity;\n      } else {\n        this.previousAngularVelocity = 0;\n      }\n      this.previousTurnDirection = 'right';\n    } else {\n      this.previousAngularVelocity = 0;\n      this.previousTurnDirection = null;\n    }\n  }\n\n  controlTilt() {\n    const maxSkisScale = 1;\n    const minSkisScale = 0.8;\n    const maxTilt = 1;\n    const minTilt = 0;\n    const tiltVelocity = 0.05;\n    let tiltAmount;\n    let tiltDirection = this.previousTiltDirection;\n    if (this.skiTiltCursors.left.isDown) {\n      if (this.previousTiltDirection !== 'right') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'left';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else if (this.skiTiltCursors.right.isDown) {\n      if (this.previousTiltDirection !== 'left') {\n        tiltAmount = _.min([this.previousTiltAmount + tiltVelocity, maxTilt]);\n        tiltDirection = 'right';\n      } else {\n        tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n      }\n    } else {\n      tiltAmount = _.max([this.previousTiltAmount - tiltVelocity, minTilt]);\n    }\n    if (tiltAmount === 0) {\n      tiltDirection = null;\n    }\n    const skisScaleX =\n      maxSkisScale * (1 - tiltAmount) + minSkisScale * tiltAmount;\n    this.leftSki.setScale(skisScaleX, maxSkisScale);\n    this.rightSki.setScale(skisScaleX, maxSkisScale);\n    this.previousTiltAmount = tiltAmount;\n    this.previousTiltDirection = tiltDirection;\n  }\n\n  drawReferenceObjects() {\n    const closestBelow =\n      Math.floor(this.skiPlayer.y / this.refDistance) * this.refDistance;\n    const closestLeft =\n      Math.floor(this.skiPlayer.x / this.refDistance) * this.refDistance;\n    const needNewRefs =\n      this.refArrows[0].x !== closestLeft ||\n      this.refArrows[0].y !== closestBelow;\n    if (needNewRefs) {\n      const closestRight = closestLeft + this.refDistance;\n      const closestAbove = closestBelow + this.refDistance;\n      this.refArrows[0].setPosition(closestLeft, closestBelow);\n      this.refArrows[1].setPosition(closestLeft, closestAbove);\n      this.refArrows[2].setPosition(closestRight, closestBelow);\n      this.refArrows[3].setPosition(closestRight, closestAbove);\n    }\n  }\n\n  crash() {\n    this.isCrashed = true;\n    this.skiPlayer.body.setVelocity(0);\n    this.skiPlayer.body.setAcceleration(0);\n    this.leftSki.destroy();\n    this.rightSki.destroy();\n    this.crashedSkis = this.add.sprite(0, 0, 'crashedSkis');\n    this.skiPlayer.add(this.crashedSkis);\n    this.edgeSnowEmitter.setScale({ start: 1, end: 0 });\n    this.edgeSnowEmitter.setAngle({ min: 0, max: 360 });\n    this.edgeSnowEmitter.setLifespan(750);\n    this.edgeSnowEmitter.explode(30, 0, 0);\n    this.cameras.main.shake(300, 0.07);\n  }\n}\n\nclass SkiTiltDisplay extends Phaser.Scene {\n  constructor() {\n    super({ key: 'SkiTiltDisplay', active: true });\n  }\n\n  /* MAIN PHASER METHODS */\n\n  preload() {\n    this.load.image(\n      'leftSkiBack',\n      publicURL('/gameAssets/images/leftSkiBack.png')\n    );\n    this.load.image(\n      'rightSkiBack',\n      publicURL('/gameAssets/images/rightSkiBack.png')\n    );\n  }\n\n  create() {\n    const displayWidth = 240;\n    const displayHeight = 110;\n    const displayCenterX = GAME_WIDTH - 45 - displayWidth / 2;\n    const displayCenterY = GAME_HEIGHT - 45 - displayHeight / 2;\n\n    const graphics = this.add.graphics();\n    graphics.setDefaultStyles({\n      lineStyle: { width: 7, color: 0x777777 },\n      fillStyle: { color: 0xdddddd },\n    });\n    graphics.strokeRect(\n      displayCenterX - displayWidth / 2,\n      displayCenterY - displayHeight / 2,\n      displayWidth,\n      displayHeight\n    );\n    graphics.fillRect(\n      displayCenterX - displayWidth / 2,\n      displayCenterY - displayHeight / 2,\n      displayWidth,\n      displayHeight\n    );\n\n    this.leftSki = this.add.sprite(-220, 0, 'leftSkiBack');\n    this.rightSki = this.add.sprite(220, 0, 'rightSkiBack');\n    this.skis = this.add.container(displayCenterX, displayCenterY, [\n      this.leftSki,\n      this.rightSki,\n    ]);\n    this.skis.setScale(0.23);\n  }\n\n  update() {\n    const slopeScene = this.scene.get('MountainSlope');\n    const {\n      previousTiltAmount: tiltAmount,\n      previousTiltDirection: tiltDirection,\n    } = slopeScene;\n    const minRotation = 0;\n    const maxRotation = Math.PI / 4;\n    const tiltRotationSign = tiltDirection === 'left' ? -1 : 1;\n    const tiltRotationMagnitude =\n      minRotation * (1 - tiltAmount) + maxRotation * tiltAmount;\n    const tiltRotation = tiltRotationMagnitude * tiltRotationSign;\n    this.leftSki.rotation = tiltRotation;\n    this.rightSki.rotation = tiltRotation;\n  }\n}\n\n/* MISC HELPERS */\n\nconst publicURL = path => {\n  return `${process.env.PUBLIC_URL}${path}`;\n};\n\nconst smallestAngleDifference = (a, b) => {\n  return Math.atan2(Math.sin(a - b), Math.cos(a - b));\n};\n\n/* MAKE GAME STARTABLE FROM ELSEWHERE */\n\nexport const initializeGame = () => {\n  const gameConfig = {\n    width: GAME_WIDTH,\n    height: GAME_HEIGHT,\n    scene: [MountainSlope, SkiTiltDisplay],\n    physics: {\n      default: 'arcade',\n    },\n    type: Phaser.AUTO,\n    parent: 'game-container',\n  };\n  const game = new Phaser.Game(gameConfig);\n  return game;\n};\n","import React, { Component } from 'react';\n\nimport { initializeGame } from 'game';\nimport 'stylesheets/components/app/app.css';\n\nclass App extends Component {\n  componentDidMount() {\n    initializeGame();\n  }\n\n  render() {\n    return (\n      <div className=\"app\">\n        <div id=\"game-container\" />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'stylesheets/index.css';\nimport App from './components/app/app';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}